{
    "docs": [
        {
            "location": "/", 
            "text": "ClimateTools.jl documentation\n\n\n\n\nClimateTools.jl documentation\n\n\nOverview\n\n\nObjectives\n\n\nInstallation\n\n\nFunctions - Climate indices\n\n\nFunctions - Reading netCDF files\n\n\nFunctions - Tools\n\n\nIndex\n\n\n\n\n\n\n\n\n\n\nOverview\n\n\nThis package is a collection of commonly-used tools in Climate Science. This is mainly a work-in-progress package, developed for myself and is available here, for \ncommon-good\n purpose as well as for archive purpose. Nothing fancy here, basics of climate field analysis will be covered, with some forays into some \n\"state-of-the-art\"\n techniques.\n\n\nThe climate indices are coded to use multiple threads. To gain maximum performance, use (bash shell) \nexport JULIA_NUM_THREADS=n\n, where \nn\n is the number of threads. To get an idea of the number of threads you can use type (in Julia) \nSys.CPU_CORES\n. This can greatly reduce calculation time.\n\n\n\n\nObjectives\n\n\n\n\nVisualization of NetCDF files (e.g. temporal mean of a given NetCDF file), for rapid evaluation of NetCDF files\n\n\nMigration of NetCDF files to Julia matrix\n\n\nClimate indices from The joint CCl/CLIVAR/JCOMM Expert Team (ET) on Climate Change Detection and Indices (ETCCDI)\n\n\nCustom climate indices\n\n\nPost-processing of climate timeseries using Quantile-Quantile mapping methods (cf. Piani et al. 2010)\n\n\n\n\n\n\nInstallation\n\n\nThis package is registered in \nMETADATA.jl\n and so can be installed using \nPkg.add\n\n\nPkg.add(\nClimateTools\n)\n\n\n\n\nFor the latest version, checkout master branch\n\n\nPkg.checkout(\nClimateTools\n)\n\n\n\n\n\n\nFunctions - Climate indices\n\n\nClimateTools.frostdays(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.icingdays(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.annualmin(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.annualmax(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.tropicalnights(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.customthresover(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day}, thres)\nClimateTools.customthresunder(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day}, thres)\nClimateTools.prcp1(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.summerdays(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\n\n\n\n\n\n\nFunctions - Reading netCDF files\n\n\n#\n\n\nClimateTools.nc2julia\n \n \nMethod\n.\n\n\nnc2julia(file::String, var::String, poly::Vector)\n\n\n\n\nReturns a ClimGrid type with the data in \nfile\n of variable \nvar\n inside the polygon \npoly\n. Metadata is built-in the ClimGrid type.\n\n\nInside the ClimgGrid type, the data is stored into an AxisArray data type, with time, longitude and latitude dimensions.\n\n\nsource\n\n\ntype ClimGrid  \n  data::AxisArray  \n  model::String\n  experiment::String\n  run::String\n  filename::String\n  dataunits::String\n  latunits::String\n  lonunits::String\nend\n\n\n\n\n\n\nFunctions - Tools\n\n\n#\n\n\nClimateTools.inpoly\n \n \nMethod\n.\n\n\ninpoly(p, poly::Matrix)\n\n\n\n\nDetermines if a point is inside a polygon.\n\n\n\n\np \u2013 point (x,y) or [x,y]\n\n\npoly \u2013 polygon vertices \nx1 x2 ... xn x1                           y1 y2 ... yn y1\n\n\n\n\nReturns true if point has an odd winding number.  This should label points as exterior which are inside outcrops.  See test for a test.\n\n\nsource\n\n\n#\n\n\nClimateTools.meshgrid\n \n \nMethod\n.\n\n\nThis function creates a 2-D mesh-grid in a format consistent with Matlab's function meshgrid()\n\n\n[X, Y] = meshgrid(XV, YV)\n\n\nwhere XV and YV are vectors.\n\n\nsource\n\n\n#\n\n\nClimateTools.windnr\n \n \nMethod\n.\n\n\nDetermines the winding number of a point and a polygon, i.e. how many times a polygon winds around the point.\n\n\nIt follows Dan Sunday: http://geomalgorithms.com/a03-_inclusion.html.\n\n\nsource\n\n\n#\n\n\nClimateTools.boxcar3\n \n \nMethod\n.\n\n\nThis function creates a boxcar averager with a window length of 3\n\n\nfunction boxcar3(A::AbstractArray)\n\n\nsource\n\n\n\n\nIndex\n\n\n\n\nClimateTools.boxcar3\n\n\nClimateTools.inpoly\n\n\nClimateTools.meshgrid\n\n\nClimateTools.nc2julia\n\n\nClimateTools.windnr", 
            "title": "Home"
        }, 
        {
            "location": "/#climatetoolsjl-documentation", 
            "text": "ClimateTools.jl documentation  Overview  Objectives  Installation  Functions - Climate indices  Functions - Reading netCDF files  Functions - Tools  Index", 
            "title": "ClimateTools.jl documentation"
        }, 
        {
            "location": "/#overview", 
            "text": "This package is a collection of commonly-used tools in Climate Science. This is mainly a work-in-progress package, developed for myself and is available here, for  common-good  purpose as well as for archive purpose. Nothing fancy here, basics of climate field analysis will be covered, with some forays into some  \"state-of-the-art\"  techniques.  The climate indices are coded to use multiple threads. To gain maximum performance, use (bash shell)  export JULIA_NUM_THREADS=n , where  n  is the number of threads. To get an idea of the number of threads you can use type (in Julia)  Sys.CPU_CORES . This can greatly reduce calculation time.", 
            "title": "Overview"
        }, 
        {
            "location": "/#objectives", 
            "text": "Visualization of NetCDF files (e.g. temporal mean of a given NetCDF file), for rapid evaluation of NetCDF files  Migration of NetCDF files to Julia matrix  Climate indices from The joint CCl/CLIVAR/JCOMM Expert Team (ET) on Climate Change Detection and Indices (ETCCDI)  Custom climate indices  Post-processing of climate timeseries using Quantile-Quantile mapping methods (cf. Piani et al. 2010)", 
            "title": "Objectives"
        }, 
        {
            "location": "/#installation", 
            "text": "This package is registered in  METADATA.jl  and so can be installed using  Pkg.add  Pkg.add( ClimateTools )  For the latest version, checkout master branch  Pkg.checkout( ClimateTools )", 
            "title": "Installation"
        }, 
        {
            "location": "/#functions-climate-indices", 
            "text": "ClimateTools.frostdays(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.icingdays(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.annualmin(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.annualmax(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.tropicalnights(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.customthresover(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day}, thres)\nClimateTools.customthresunder(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day}, thres)\nClimateTools.prcp1(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})\nClimateTools.summerdays(data::Array{Float64, 1}, timeV::StepRange{Date, Base.Dates.Day})", 
            "title": "Functions - Climate indices"
        }, 
        {
            "location": "/#functions-reading-netcdf-files", 
            "text": "#  ClimateTools.nc2julia     Method .  nc2julia(file::String, var::String, poly::Vector)  Returns a ClimGrid type with the data in  file  of variable  var  inside the polygon  poly . Metadata is built-in the ClimGrid type.  Inside the ClimgGrid type, the data is stored into an AxisArray data type, with time, longitude and latitude dimensions.  source  type ClimGrid  \n  data::AxisArray  \n  model::String\n  experiment::String\n  run::String\n  filename::String\n  dataunits::String\n  latunits::String\n  lonunits::String\nend", 
            "title": "Functions - Reading netCDF files"
        }, 
        {
            "location": "/#functions-tools", 
            "text": "#  ClimateTools.inpoly     Method .  inpoly(p, poly::Matrix)  Determines if a point is inside a polygon.   p \u2013 point (x,y) or [x,y]  poly \u2013 polygon vertices  x1 x2 ... xn x1                           y1 y2 ... yn y1   Returns true if point has an odd winding number.  This should label points as exterior which are inside outcrops.  See test for a test.  source  #  ClimateTools.meshgrid     Method .  This function creates a 2-D mesh-grid in a format consistent with Matlab's function meshgrid()  [X, Y] = meshgrid(XV, YV)  where XV and YV are vectors.  source  #  ClimateTools.windnr     Method .  Determines the winding number of a point and a polygon, i.e. how many times a polygon winds around the point.  It follows Dan Sunday: http://geomalgorithms.com/a03-_inclusion.html.  source  #  ClimateTools.boxcar3     Method .  This function creates a boxcar averager with a window length of 3  function boxcar3(A::AbstractArray)  source", 
            "title": "Functions - Tools"
        }, 
        {
            "location": "/#index", 
            "text": "ClimateTools.boxcar3  ClimateTools.inpoly  ClimateTools.meshgrid  ClimateTools.nc2julia  ClimateTools.windnr", 
            "title": "Index"
        }
    ]
}