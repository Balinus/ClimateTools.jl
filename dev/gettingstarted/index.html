<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · ClimateTools.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="ClimateTools.jl logo"/></a><h1>ClimateTools.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Getting started</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Required-dependencies-1">Required dependencies</a></li><li><a class="toctext" href="#Reading-a-NetCDF-file-1">Reading a NetCDF file</a></li><li><a class="toctext" href="#Subsetting-1">Subsetting</a></li></ul></li><li><a class="toctext" href="../indices/">Climate Indices</a></li><li><a class="toctext" href="../interpolation/">Interpolation</a></li><li><a class="toctext" href="../biascorrection/">Bias correction</a></li><li><a class="toctext" href="../maps/">Visualization</a></li><li><a class="toctext" href="../interface/">Interface</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../functions/">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Getting started</a></li></ul><a class="edit-page" href="https://github.com/Balinus/ClimateTools.jl/blob/master/docs/src/gettingstarted.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Getting started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><h2><a class="nav-anchor" id="Required-dependencies-1" href="#Required-dependencies-1">Required dependencies</a></h2><p>ClimateTools need some Python dependencies for mapping purpose. To ensure that ClimateTools works properly, it is recommended to use a Python distribution that can properly load the following python modules and build <code>PyCall</code> with the same python distribution.</p><p><strong>Python dependencies</strong></p><ul><li>matplotlib (tested with version 2.0.1)</li><li>basemap (tested with version 1.0.7)</li><li>scipy (tested with version 1.0.1)</li><li>cmocean</li></ul><p><em>Note2. Installing Basemap for python 3.6+ seems problematic.</em></p><p><strong>Building PyCall</strong> After the confirmation that the Python dependencies can be loaded in Python, the user needs to build PyCall with the same Python version. Alternatively, if PyCall is already built, it may be only a matter of installing the Python dependencies with the PyCall&#39;s Python version.</p><pre><code class="language-julia">ENV[&quot;PYTHON&quot;]=&quot;path_to_python_distribution&quot;
pkg&gt; build PyCall</code></pre><h3><a class="nav-anchor" id="Installing-ClimateTools.jl-1" href="#Installing-ClimateTools.jl-1">Installing ClimateTools.jl</a></h3><pre><code class="language-julia">pkg&gt; add ClimateTools # Tagged release</code></pre><h2><a class="nav-anchor" id="Reading-a-NetCDF-file-1" href="#Reading-a-NetCDF-file-1">Reading a NetCDF file</a></h2><p>The entry point of <code>ClimateTools</code> is to load data with the <code>load</code> function. The return structure of the <code>load</code> function is a in-memory representation of the variable contained in the netCDF file.</p><pre><code class="language-julia">C = load(filename::String, vari::String; poly::Array, data_units::String, start_date::Tuple, end_date::Tuple, dimension::Bool=true)</code></pre><p><code>load</code> return a <code>ClimGrid</code> type. The <code>ClimGrid</code> represent a single variable. By default, the function tries to attach physical units to the data array by using the <a href="https://github.com/ajkeller34/Unitful.jl">Unitful.jl</a> package. The advantage behind physical units is that one can subtract a <code>ClimGrid</code> with <code>Kelvin</code> unit with a <code>ClimGrid</code> with <code>Celsius</code> unit and get coherent results. Be warned that some operations on some units are not allowed (you cannot &quot;add&quot; Celsius for instance). In the event that a user wants to do some calculations without physical logic, it is possible to load the dataset without the units by specifying <code>dimension=false</code> argument. </p><p>Using the optional <code>poly</code> argument, the user can provide a polygon and the returned <code>ClimGrid</code> will only contains the grid points inside the provided polygon. <strong>The polygon provided should be in the -180, +180 longitude format. If the polygon crosses the International Date Line, the polygon should be splitted in multiple parts (i.e. multi-polygons).</strong></p><p><code>start_date</code> and <code>end_date</code> can also be provided. It is useful when climate simulations file spans multiple decades/centuries and only a temporal subset is needed. Dates should be provided as a <code>Tuple</code> of the form <code>(year, month, day, hour, minute, seconds)</code>, where only <code>year</code> is mandatory (e.g. <code>(2000,)</code> can be provided and will defaults to <code>(2000, 01, 01)</code>).</p><p>For some variable, the optional keyword argument <code>data_units</code> can be provided. For example, precipitation in climate models are usually provided as <code>kg/m^2/s</code>. By specifying <code>data_units = mm</code>, the <code>load</code> function returns accumulation at the data time resolution. Similarly, the user can provide <code>Celsius</code> as <code>data_units</code> and <code>load</code> will return <code>Celsius</code> instead of <code>Kelvin</code>.</p><pre><code class="language-julia">struct ClimGrid
  data::AxisArray # Data
  longrid::AbstractArray{N,2} where N # the longitude grid
  latgrid::AbstractArray{N,2} where N # the latitude grid
  msk::Array{N, 2} where N # Data mask (NaNs and 1.0)
  grid_mapping::Dict#{String, Any} # bindings for native grid
  dimension_dict::Dict
  model::String
  frequency::String # Day, month, years
  experiment::String # Historical, RCP4.5, RCP8.5, etc.
  run::String
  project::String # CORDEX, CMIP5, etc.
  institute::String # UQAM, DMI, etc.
  filename::String # Path of the original file
  dataunits::String # Celsius, kelvin, etc.
  latunits::String # latitude coordinate unit
  lonunits::String # longitude coordinate unit
  variable::String # Type of variable (i.e. can be the same as &quot;typeofvar&quot;, but it is changed when calculating indices)
  typeofvar::String # Variable type (e.g. tasmax, tasmin, pr)
  typeofcal::String # Calendar type
  timeattrib::Dict # Time attributes (e.g. days since ... )
  varattribs::Dict # Variable attributes dictionary
  globalattribs::Dict # Global attributes dictionary
end</code></pre><h2><a class="nav-anchor" id="Subsetting-1" href="#Subsetting-1">Subsetting</a></h2><p>Once the data is loaded in a <code>ClimGrid</code> struct, options to further subset the data are available.</p><h3><a class="nav-anchor" id="Spatial-1" href="#Spatial-1">Spatial</a></h3><p><code>spatialsubset</code> function acts on <code>ClimGrid</code> type and subset the data through a spatial subset using a provided polygon. The function returns a <code>ClimGrid</code>. <strong>Polygons needs to be on a -180, +180 longitude coordinates, as data coordinates defaults to such grid.</strong> For instance, global models are often on a 0-360 degrees grid but the load function shift the data onto a -180,+180 coordinates.</p><pre><code class="language-julia">C = spatialsubset(C::ClimGrid, poly:Array{N, 2} where N)</code></pre><h3><a class="nav-anchor" id="Temporal-1" href="#Temporal-1">Temporal</a></h3><p>Temporal subset of the data is also possible with the <code>temporalsubset</code> function:</p><pre><code class="language-julia">C = temporalsubset(C::ClimGrid, startdate::Tuple, enddate::Tuple)</code></pre><h3><a class="nav-anchor" id="Discontinuous-temporal-(e.g.-resampling)-1" href="#Discontinuous-temporal-(e.g.-resampling)-1">Discontinuous temporal (e.g. resampling)</a></h3><p>It is also possible to only keep a given non-continuous period for a given timeframe. For example, we might be interested in keeping only northern summer months (June-July-August) from a continuous ClimGrid covering 1961-2100. <code>resample</code> returns such a subsetted ClimGrid.</p><pre><code class="language-julia">Csub = resample(C, &quot;JJA&quot;) # hardcoded ClimateTools&#39;s season
Csub = resample(C, 6, 8) # custom subset example for June-July-August
Csub = resample(C, 1, 2) # custom subset example for January-February</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../indices/"><span class="direction">Next</span><span class="title">Climate Indices</span></a></footer></article></body></html>
