{
    "docs": [
        {
            "location": "/", 
            "text": "ClimateTools.jl\n\n\n\n\n\n\n\n\nPackage Status\n\n\nPackage Evaluator\n\n\nBuild Status\n\n\nDOI\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOverview\n\n\nThis package is a collection of commonly-used tools in Climate Science. Basics of climate field analysis will be covered, with some forays into exploratory techniques. The package is aimed to ease the typical steps of analysis climate models outputs and observed time series from weather stations.\n\n\nThis package is registered on METADATA.jl and can be added with \nPkg.add(\"ClimateTools\")\n and used with \nusing ClimateTools\n.\n\n\n\n\nInstallation\n\n\nPkg.add(\nClimateTools\n) # Tagged release\nPkg.checkout(\nClimateTools\n) # For latest master branch\n\n\n\n\n\n\nNotes\n\n\nThe climate indices are coded to use \nmultiple threads\n. To gain maximum performance, use (bash shell) \nexport JULIA_NUM_THREADS=n\n, where \nn\n is the number of threads. To get an idea of the number of threads you can use type (in Julia) \nSys.CPU_CORES\n.\n\n\n\n\nObjectives\n\n\n\n\nExtraction and visualization of NetCDF datasets, with user-provided polygons and start and end date.\n\n\nClimate indices from The joint CCl/CLIVAR/JCOMM Expert Team (ET) on Climate Change Detection and Indices (ETCCDI)\n\n\nCustom climate indices\n\n\nInterpolation of a datasets onto another grid\n\n\nPost-processing of climate timeseries using Quantile-Quantile mapping method (cf. Piani et al. 2010)\n\n\n\n\n\n\nContributors\n\n\nIf you'd like to have other climate indices coded, please, submit them through a Pull Request! I'd be more than happy to include them. Alternatively, provide the equation in Issues.\n\n\n\n\nTO-DO\n\n\n\n\nAdd a standard quantile-quantile mapping technique\n\n\nDashboard tool. This will return the main characteristics of a ClimGrid: maps of minimum, maximum and mean climatological values, seasonal cycle, timeseries of annual maximum, minimum and mean values, etc...\n\n\nCreate a WeatherStation type.\n\n\nExport ClimGrid to netCDF file.\n\n\nAdd a more complex quantile-quantile mapping technique, combining extreme value theory and quantile-quantile standard technique\n\n\nAdd GRIB file support (probably through \nGMT.jl\n)\n\n\n\n\nN.B. version 0.1.2 is compatible with Julia 0.5 and version \n0.2.0 is for Julia 0.6. To use a specific version of the package, you can use in Julia the following command:\n\n\nPkg.pin(\nClimateTools\n,v\n0.1.2\n) # if using Julia 0.5", 
            "title": "Home"
        }, 
        {
            "location": "/#climatetoolsjl", 
            "text": "Package Status  Package Evaluator  Build Status  DOI", 
            "title": "ClimateTools.jl"
        }, 
        {
            "location": "/#overview", 
            "text": "This package is a collection of commonly-used tools in Climate Science. Basics of climate field analysis will be covered, with some forays into exploratory techniques. The package is aimed to ease the typical steps of analysis climate models outputs and observed time series from weather stations.  This package is registered on METADATA.jl and can be added with  Pkg.add(\"ClimateTools\")  and used with  using ClimateTools .", 
            "title": "Overview"
        }, 
        {
            "location": "/#installation", 
            "text": "Pkg.add( ClimateTools ) # Tagged release\nPkg.checkout( ClimateTools ) # For latest master branch", 
            "title": "Installation"
        }, 
        {
            "location": "/#notes", 
            "text": "The climate indices are coded to use  multiple threads . To gain maximum performance, use (bash shell)  export JULIA_NUM_THREADS=n , where  n  is the number of threads. To get an idea of the number of threads you can use type (in Julia)  Sys.CPU_CORES .", 
            "title": "Notes"
        }, 
        {
            "location": "/#objectives", 
            "text": "Extraction and visualization of NetCDF datasets, with user-provided polygons and start and end date.  Climate indices from The joint CCl/CLIVAR/JCOMM Expert Team (ET) on Climate Change Detection and Indices (ETCCDI)  Custom climate indices  Interpolation of a datasets onto another grid  Post-processing of climate timeseries using Quantile-Quantile mapping method (cf. Piani et al. 2010)", 
            "title": "Objectives"
        }, 
        {
            "location": "/#contributors", 
            "text": "If you'd like to have other climate indices coded, please, submit them through a Pull Request! I'd be more than happy to include them. Alternatively, provide the equation in Issues.", 
            "title": "Contributors"
        }, 
        {
            "location": "/#to-do", 
            "text": "Add a standard quantile-quantile mapping technique  Dashboard tool. This will return the main characteristics of a ClimGrid: maps of minimum, maximum and mean climatological values, seasonal cycle, timeseries of annual maximum, minimum and mean values, etc...  Create a WeatherStation type.  Export ClimGrid to netCDF file.  Add a more complex quantile-quantile mapping technique, combining extreme value theory and quantile-quantile standard technique  Add GRIB file support (probably through  GMT.jl )   N.B. version 0.1.2 is compatible with Julia 0.5 and version  0.2.0 is for Julia 0.6. To use a specific version of the package, you can use in Julia the following command:  Pkg.pin( ClimateTools ,v 0.1.2 ) # if using Julia 0.5", 
            "title": "TO-DO"
        }, 
        {
            "location": "/gettingstarted/", 
            "text": "Getting started\n\n\n\n\nReading a NetCDF file\n\n\nThe entry point of \nClimateTools\n is to load data with the \nnc2julia\n function. Optional polygon clipping feature is available. By providing such polygon, the \nnc2julia\n function  returns a \nClimGrid\n with grid points contained in the polygon.\n\n\nC = nc2julia(filename::String, var::String; poly::Array, data_units::String, start_date::Date, end_date::Date)\n\n\n\n\nnc2julia\n return a \nClimGrid\n type. Using the optional \npoly\n argument, the user can provide a polygon and the returned \nClimGrid\n will only contains the grid points inside the provided polygon. For some variable, the optional keyword argument \ndata_units\n can be provided. For example, precipitation in climate models are usually provided as \nkg/m^2/s\n. By specifying \ndata_units = mm\n, the \nnc2julia\n function returns accumulation at the data time resolution. Similarly, the user can provide \nCelsius\n as \ndata_units\n and \nnc2julia\n will return \nCelsius\n instead of \nKelvin\n.\n\n\nThe \nClimGrid\n is a in-memory representation of a CF-compliant netCDF file for a single variable.\n\n\nstruct ClimGrid{A \n: AxisArray}\n# struct ClimGrid\n  data::A\n  longrid::AbstractArray{N,2} where N # the longitude grid\n  latgrid::AbstractArray{N,2} where N # the latitude grid\n  msk::Array{N, 2} where N\n  grid_mapping::Dict#{String, Any} # bindings for native grid\n  dimension_dict::Dict\n  model::String\n  frequency::String\n  experiment::String\n  run::String\n  project::String # CORDEX, CMIP5, etc.\n  institute::String\n  filename::String\n  dataunits::String\n  latunits::String # of the coordinate variable\n  lonunits::String # of the coordinate variable\n  variable::String # Type of variable (i.e. can be the same as \nvar\n, but it is changed when calculating indices)\n  typeofvar::String # Variable type (e.g. tasmax, tasmin, pr)\n  typeofcal::String # Calendar type\n  varattribs::Dict # Variable attributes\n  globalattribs::Dict # Global attributes\n\nend\n\n\n\n\nThere is a \nspatialsubset\n function which acts on \nClimGrid\n type and further subset the data through a spatial subset using a provided polygon. The function returns a \nClimGrid\n. Polygons needs to be on a -180, +180 longitude coordinates.\n\n\nC = spatialsubset(C::ClimGrid, poly:Array{N, 2} where N)\n\n\n\n\nTemporal subset of the data is also possible with the \ntemporalsubset\n function:\n\n\nC = temporalsubset(C::ClimGrid, startdate::Date, enddate::Date)\n\n\n\n\n\n\nIndex\n\n\n\n\nClimateTools.annualmax\n\n\nClimateTools.inpoly\n\n\nClimateTools.windnr\n\n\n\n\n\u2013", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#reading-a-netcdf-file", 
            "text": "The entry point of  ClimateTools  is to load data with the  nc2julia  function. Optional polygon clipping feature is available. By providing such polygon, the  nc2julia  function  returns a  ClimGrid  with grid points contained in the polygon.  C = nc2julia(filename::String, var::String; poly::Array, data_units::String, start_date::Date, end_date::Date)  nc2julia  return a  ClimGrid  type. Using the optional  poly  argument, the user can provide a polygon and the returned  ClimGrid  will only contains the grid points inside the provided polygon. For some variable, the optional keyword argument  data_units  can be provided. For example, precipitation in climate models are usually provided as  kg/m^2/s . By specifying  data_units = mm , the  nc2julia  function returns accumulation at the data time resolution. Similarly, the user can provide  Celsius  as  data_units  and  nc2julia  will return  Celsius  instead of  Kelvin .  The  ClimGrid  is a in-memory representation of a CF-compliant netCDF file for a single variable.  struct ClimGrid{A  : AxisArray}\n# struct ClimGrid\n  data::A\n  longrid::AbstractArray{N,2} where N # the longitude grid\n  latgrid::AbstractArray{N,2} where N # the latitude grid\n  msk::Array{N, 2} where N\n  grid_mapping::Dict#{String, Any} # bindings for native grid\n  dimension_dict::Dict\n  model::String\n  frequency::String\n  experiment::String\n  run::String\n  project::String # CORDEX, CMIP5, etc.\n  institute::String\n  filename::String\n  dataunits::String\n  latunits::String # of the coordinate variable\n  lonunits::String # of the coordinate variable\n  variable::String # Type of variable (i.e. can be the same as  var , but it is changed when calculating indices)\n  typeofvar::String # Variable type (e.g. tasmax, tasmin, pr)\n  typeofcal::String # Calendar type\n  varattribs::Dict # Variable attributes\n  globalattribs::Dict # Global attributes\n\nend  There is a  spatialsubset  function which acts on  ClimGrid  type and further subset the data through a spatial subset using a provided polygon. The function returns a  ClimGrid . Polygons needs to be on a -180, +180 longitude coordinates.  C = spatialsubset(C::ClimGrid, poly:Array{N, 2} where N)  Temporal subset of the data is also possible with the  temporalsubset  function:  C = temporalsubset(C::ClimGrid, startdate::Date, enddate::Date)", 
            "title": "Reading a NetCDF file"
        }, 
        {
            "location": "/gettingstarted/#index", 
            "text": "ClimateTools.annualmax  ClimateTools.inpoly  ClimateTools.windnr   \u2013", 
            "title": "Index"
        }, 
        {
            "location": "/indices/", 
            "text": "Indices in ClimateTools package (WIP)\n\n\n\n\nIndices\n\n\nMore than 20 climate indices are available in the package, such as the annual number of tropical nights, annual maximum and minimum, etc. You can calculate such indices simply with:\n\n\nind = annualmax(C::ClimGrid)\n\n\n\n\nWhich returns another \nClimGrid\n. You can also map this \nClimGrid\n with the \nmapclimgrid\n function and returns the climatological mean of the annual maximum (e.g. daily precipitation in the example below). A list of indices can be found in the documentation and in the \nfunctions.jl\n source code.\n\n\n   \n \n\n\n\nClimate Indices functions also accept other type of argument. For example, \nannualmax\n can be called with the following type:\n\n\nind = annualmax(data::Array{Float64, 3}, dates::StepRange{Date, Base.Dates.Day})\n\n\n\n\n\n\nAnnual indices\n\n\n#\n\n\nClimateTools.annualmax\n \n \nFunction\n.\n\n\nannualmax(C::ClimGrid)\n\n\n\n\nAnnual maximum of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.\n\n\nsource\n\n\nannualmax(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})\n\n\n\n\nAnnual maximum of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.\n\n\nsource\n\n\n\n\nFunctions - Tools\n\n\n#\n\n\nClimateTools.inpoly\n \n \nMethod\n.\n\n\ninpoly(p, poly::Matrix)\n\n\n\n\nDetermines if a point is inside a polygon.\n\n\n\n\np \u2013 point (x,y) or [x,y]\n\n\npoly \u2013 polygon vertices \nx1 x2 ... xn x1                           y1 y2 ... yn y1\n\n\n\n\nReturns true if point has an odd winding number.  This should label points as exterior which are inside outcrops.  See test for a test.\n\n\nAuthor: Github \"Mauro3\" / \"Mauro\"\n\n\nsource\n\n\n#\n\n\nClimateTools.windnr\n \n \nMethod\n.\n\n\nwindnr(p, poly::Matrix)\n\n\n\n\nDetermines the winding number of a point and a polygon, i.e. how many times a polygon winds around the point.\n\n\nIt follows Dan Sunday: http://geomalgorithms.com/a03-_inclusion.html.\n\n\nsource\n\n\n\n\nSeasonal indices\n\n\nComing soon.", 
            "title": "Climate indices"
        }, 
        {
            "location": "/indices/#indices-in-climatetools-package-wip", 
            "text": "", 
            "title": "Indices in ClimateTools package (WIP)"
        }, 
        {
            "location": "/indices/#indices", 
            "text": "More than 20 climate indices are available in the package, such as the annual number of tropical nights, annual maximum and minimum, etc. You can calculate such indices simply with:  ind = annualmax(C::ClimGrid)  Which returns another  ClimGrid . You can also map this  ClimGrid  with the  mapclimgrid  function and returns the climatological mean of the annual maximum (e.g. daily precipitation in the example below). A list of indices can be found in the documentation and in the  functions.jl  source code.         Climate Indices functions also accept other type of argument. For example,  annualmax  can be called with the following type:  ind = annualmax(data::Array{Float64, 3}, dates::StepRange{Date, Base.Dates.Day})", 
            "title": "Indices"
        }, 
        {
            "location": "/indices/#annual-indices", 
            "text": "#  ClimateTools.annualmax     Function .  annualmax(C::ClimGrid)  Annual maximum of array data.  Let data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.  source  annualmax(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})  Annual maximum of array data.  Let data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.  source", 
            "title": "Annual indices"
        }, 
        {
            "location": "/indices/#functions-tools", 
            "text": "#  ClimateTools.inpoly     Method .  inpoly(p, poly::Matrix)  Determines if a point is inside a polygon.   p \u2013 point (x,y) or [x,y]  poly \u2013 polygon vertices  x1 x2 ... xn x1                           y1 y2 ... yn y1   Returns true if point has an odd winding number.  This should label points as exterior which are inside outcrops.  See test for a test.  Author: Github \"Mauro3\" / \"Mauro\"  source  #  ClimateTools.windnr     Method .  windnr(p, poly::Matrix)  Determines the winding number of a point and a polygon, i.e. how many times a polygon winds around the point.  It follows Dan Sunday: http://geomalgorithms.com/a03-_inclusion.html.  source", 
            "title": "Functions - Tools"
        }, 
        {
            "location": "/indices/#seasonal-indices", 
            "text": "Coming soon.", 
            "title": "Seasonal indices"
        }, 
        {
            "location": "/interpolation/", 
            "text": "Interpolation\n\n\nA typical step in climate analysis is to interpolate a given grid onto another grid. \nClimateTools\n provides such a tool by wrapping Scipy griddata function. It is intended for visualization or as a 1st step before bias-correcting the \nClimGrid\n dataset.\n\n\nThe following command will interpolate the data contained in \nClimGrid A\n into the coordinates of \nClimGrid B\n and returns a new \nClimGrid C\n which contains the interpolated data of \nA\n into the grid of \nB\n.\n\n\nC = interp_climgrid(A::ClimGrid, B::ClimGrid)\n\n\n\n\nIt is also possible to interpolate a \nClimGrid\n onto specified longitude and latitude vectors.\n\n\nC = interp_climgrid(A::ClimGrid, lon::AbstractArray{N, 1}, lat::AbstractArray{N, 1})", 
            "title": "Interpolation"
        }, 
        {
            "location": "/interpolation/#interpolation", 
            "text": "A typical step in climate analysis is to interpolate a given grid onto another grid.  ClimateTools  provides such a tool by wrapping Scipy griddata function. It is intended for visualization or as a 1st step before bias-correcting the  ClimGrid  dataset.  The following command will interpolate the data contained in  ClimGrid A  into the coordinates of  ClimGrid B  and returns a new  ClimGrid C  which contains the interpolated data of  A  into the grid of  B .  C = interp_climgrid(A::ClimGrid, B::ClimGrid)  It is also possible to interpolate a  ClimGrid  onto specified longitude and latitude vectors.  C = interp_climgrid(A::ClimGrid, lon::AbstractArray{N, 1}, lat::AbstractArray{N, 1})", 
            "title": "Interpolation"
        }, 
        {
            "location": "/biascorrection/", 
            "text": "Bias correction", 
            "title": "Bias correction"
        }, 
        {
            "location": "/biascorrection/#bias-correction", 
            "text": "", 
            "title": "Bias correction"
        }, 
        {
            "location": "/maps/", 
            "text": "Maps\n\n\n\n\nMapping the ClimGrid type\n\n\nMapping climate information can be done by using \nmapclimgrid\n:\n\n\nmapclimgrid(C::ClimGrid; region = \nWorld\n)\n\n\n\n\nWhich should return\n\n\n   \n \n\n\n\nNote that if the \nClimGrid\n data structure has 3 dimensions (time x longitude x latitude) the \nmapclimgrid\n function makes a time-average (i.e. climatological mean). Right now, options are available for region: \nWorld\n, \nCanada\n, \nQuebec\n and the default \nauto\n which use the maximum and minimum of the lat-long coordinates inside the \nClimGrid\n structure. The user can also provide a polygon(s) and the \nmapclimgrid\n function will clip the grid points outside the specified polygon. Another option is to provide a mask (with dimensions identical to the spatial dimension of the \nClimGrid\n data) which contains \nNaN\n and \n1.0\n and the data inside the \nClimGrid\n struct will be clipped with the mask. Other regions will be added in the future, as well as the option to send a custom region defined by a lat-lon box.\n\n\nIn a future release, the user will have the option to specify his own time period (e.g. plotting the time-average of a given month and year, as opposed to the time-average of the whole \nClimGrid\n structure).", 
            "title": "Maps"
        }, 
        {
            "location": "/maps/#maps", 
            "text": "", 
            "title": "Maps"
        }, 
        {
            "location": "/maps/#mapping-the-climgrid-type", 
            "text": "Mapping climate information can be done by using  mapclimgrid :  mapclimgrid(C::ClimGrid; region =  World )  Which should return         Note that if the  ClimGrid  data structure has 3 dimensions (time x longitude x latitude) the  mapclimgrid  function makes a time-average (i.e. climatological mean). Right now, options are available for region:  World ,  Canada ,  Quebec  and the default  auto  which use the maximum and minimum of the lat-long coordinates inside the  ClimGrid  structure. The user can also provide a polygon(s) and the  mapclimgrid  function will clip the grid points outside the specified polygon. Another option is to provide a mask (with dimensions identical to the spatial dimension of the  ClimGrid  data) which contains  NaN  and  1.0  and the data inside the  ClimGrid  struct will be clipped with the mask. Other regions will be added in the future, as well as the option to send a custom region defined by a lat-lon box.  In a future release, the user will have the option to specify his own time period (e.g. plotting the time-average of a given month and year, as opposed to the time-average of the whole  ClimGrid  structure).", 
            "title": "Mapping the ClimGrid type"
        }, 
        {
            "location": "/interface/", 
            "text": "Interface\n\n\n\n\nMerging ClimGrid type\n\n\nSometimes, the timeseries are split among multiple files (e.g. climate models outputs). To obtain the complete timeseries, you can \nmerge\n 2 \nClimGrid\n. The method is based on the merging of 2 \nAxisArrays\n and is overloaded for the \nClimGrid\n type.\n\n\nC = merge(C1::ClimGrid, C2::ClimGrid)", 
            "title": "Interface"
        }, 
        {
            "location": "/interface/#interface", 
            "text": "", 
            "title": "Interface"
        }, 
        {
            "location": "/interface/#merging-climgrid-type", 
            "text": "Sometimes, the timeseries are split among multiple files (e.g. climate models outputs). To obtain the complete timeseries, you can  merge  2  ClimGrid . The method is based on the merging of 2  AxisArrays  and is overloaded for the  ClimGrid  type.  C = merge(C1::ClimGrid, C2::ClimGrid)", 
            "title": "Merging ClimGrid type"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }
    ]
}