{
    "docs": [
        {
            "location": "/", 
            "text": "ClimateTools.jl\n\n\n\n\nOverview\n\n\nThis package is a collection of commonly-used tools in Climate Science. Basics of climate field analysis will be covered, with some forays into exploratory techniques. The package is aimed to ease the typical steps of analysis climate models outputs from netCDF files that follows \nClimate Forecast conventions\n.\n\n\nThis package is registered on METADATA.jl and can be added with \nPkg.add(\"ClimateTools\")\n and used with \nusing ClimateTools\n.\n\n\n\n\nInstallation\n\n\nPkg.add(\nClimateTools\n) # Tagged release\nPkg.checkout(\nClimateTools\n) # For latest master branch\n\n\n\n\n\n\nNotes\n\n\nThe climate indices are coded to use \nmultiple threads\n. To gain maximum performance, use (bash shell) \nexport JULIA_NUM_THREADS=n\n, where \nn\n is the number of threads. To get an idea of the number of threads you can use type (in Julia) \nSys.CPU_CORES\n.\n\n\n\n\nObjectives\n\n\n\n\nExtraction and visualization of NetCDF datasets, with user-provided polygons and start and end date.\n\n\nClimate indices from The joint CCl/CLIVAR/JCOMM Expert Team (ET) on Climate Change Detection and Indices (ETCCDI)\n\n\nCustom climate indices\n\n\nInterpolation of a datasets onto another grid\n\n\nPost-processing of climate timeseries using Quantile-Quantile mapping method (cf. Theme\u00dfl et al. 2012, Piani et al. 2010)\n\n\n\n\n\n\nContributors\n\n\nIf you'd like to have other climate indices coded, please, submit them through a Pull Request! I'd be more than happy to include them. Alternatively, provide the equation in Issues.\n\n\n\n\nTO-DO\n\n\n\n\nDashboard tool. This will return the main characteristics of a ClimGrid: maps of minimum, maximum and mean climatological values, seasonal cycle, timeseries of annual maximum, minimum and mean values, etc...\n\n\nExport ClimGrid to netCDF file.\n\n\nAdd a more complex quantile-quantile mapping technique, combining extreme value theory and quantile-quantile standard technique\n\n\n\n\n\n\nNotes\n\n\nN.B. version 0.1.2 is compatible with Julia 0.5 and version \n0.2.0 is for Julia 0.6. To use a specific version of the package, you can use in Julia the following command:\n\n\nPkg.pin(\nClimateTools\n,v\n0.1.2\n) # if using Julia 0.5", 
            "title": "Home"
        }, 
        {
            "location": "/#climatetoolsjl", 
            "text": "", 
            "title": "ClimateTools.jl"
        }, 
        {
            "location": "/#overview", 
            "text": "This package is a collection of commonly-used tools in Climate Science. Basics of climate field analysis will be covered, with some forays into exploratory techniques. The package is aimed to ease the typical steps of analysis climate models outputs from netCDF files that follows  Climate Forecast conventions .  This package is registered on METADATA.jl and can be added with  Pkg.add(\"ClimateTools\")  and used with  using ClimateTools .", 
            "title": "Overview"
        }, 
        {
            "location": "/#installation", 
            "text": "Pkg.add( ClimateTools ) # Tagged release\nPkg.checkout( ClimateTools ) # For latest master branch", 
            "title": "Installation"
        }, 
        {
            "location": "/#notes", 
            "text": "The climate indices are coded to use  multiple threads . To gain maximum performance, use (bash shell)  export JULIA_NUM_THREADS=n , where  n  is the number of threads. To get an idea of the number of threads you can use type (in Julia)  Sys.CPU_CORES .", 
            "title": "Notes"
        }, 
        {
            "location": "/#objectives", 
            "text": "Extraction and visualization of NetCDF datasets, with user-provided polygons and start and end date.  Climate indices from The joint CCl/CLIVAR/JCOMM Expert Team (ET) on Climate Change Detection and Indices (ETCCDI)  Custom climate indices  Interpolation of a datasets onto another grid  Post-processing of climate timeseries using Quantile-Quantile mapping method (cf. Theme\u00dfl et al. 2012, Piani et al. 2010)", 
            "title": "Objectives"
        }, 
        {
            "location": "/#contributors", 
            "text": "If you'd like to have other climate indices coded, please, submit them through a Pull Request! I'd be more than happy to include them. Alternatively, provide the equation in Issues.", 
            "title": "Contributors"
        }, 
        {
            "location": "/#to-do", 
            "text": "Dashboard tool. This will return the main characteristics of a ClimGrid: maps of minimum, maximum and mean climatological values, seasonal cycle, timeseries of annual maximum, minimum and mean values, etc...  Export ClimGrid to netCDF file.  Add a more complex quantile-quantile mapping technique, combining extreme value theory and quantile-quantile standard technique", 
            "title": "TO-DO"
        }, 
        {
            "location": "/#notes_1", 
            "text": "N.B. version 0.1.2 is compatible with Julia 0.5 and version  0.2.0 is for Julia 0.6. To use a specific version of the package, you can use in Julia the following command:  Pkg.pin( ClimateTools ,v 0.1.2 ) # if using Julia 0.5", 
            "title": "Notes"
        }, 
        {
            "location": "/gettingstarted/", 
            "text": "Getting started\n\n\n\n\nReading a NetCDF file\n\n\nThe entry point of \nClimateTools\n is to load data with the \nnc2julia\n function. Optional polygon clipping feature is available. By providing such polygon, the \nnc2julia\n function  returns a \nClimGrid\n with grid points contained in the polygon.\n\n\nC = nc2julia(filename::String, var::String; poly::Array, data_units::String, start_date::Date, end_date::Date)\n\n\n\n\nnc2julia\n return a \nClimGrid\n type. Using the optional \npoly\n argument, the user can provide a polygon and the returned \nClimGrid\n will only contains the grid points inside the provided polygon. The polygon provided should be in the -180, +180 longitude format. If the polygon crosses the International Date Line, the polygon should be splitted in multiple parts (i.e. multi-polygons).\n\n\nFor some variable, the optional keyword argument \ndata_units\n can be provided. For example, precipitation in climate models are usually provided as \nkg/m^2/s\n. By specifying \ndata_units = mm\n, the \nnc2julia\n function returns accumulation at the data time resolution. Similarly, the user can provide \nCelsius\n as \ndata_units\n and \nnc2julia\n will return \nCelsius\n instead of \nKelvin\n.\n\n\nThe \nClimGrid\n is a in-memory representation of a CF-compliant netCDF file for a single variable.\n\n\nstruct ClimGrid{A \n: AxisArray}\n# struct ClimGrid\n  data::A\n  longrid::AbstractArray{N,2} where N # the longitude grid\n  latgrid::AbstractArray{N,2} where N # the latitude grid\n  msk::Array{N, 2} where N\n  grid_mapping::Dict#{String, Any} # bindings for native grid\n  dimension_dict::Dict\n  model::String\n  frequency::String\n  experiment::String\n  run::String\n  project::String # CORDEX, CMIP5, etc.\n  institute::String\n  filename::String\n  dataunits::String\n  latunits::String # of the coordinate variable\n  lonunits::String # of the coordinate variable\n  variable::String # Type of variable (i.e. can be the same as \nvar\n, but it is changed when calculating indices)\n  typeofvar::String # Variable type (e.g. tasmax, tasmin, pr)\n  typeofcal::String # Calendar type\n  varattribs::Dict # Variable attributes\n  globalattribs::Dict # Global attributes\n\nend\n\n\n\n\nThere is a \nspatialsubset\n function which acts on \nClimGrid\n type and further subset the data through a spatial subset using a provided polygon. The function returns a \nClimGrid\n. \nPolygons needs to be on a -180, +180 longitude coordinates, as data coordinates defaults to such grid.\n For instance, global models are often on a 0-360 degrees grid.\n\n\nC = spatialsubset(C::ClimGrid, poly:Array{N, 2} where N)\n\n\n\n\nTemporal subset of the data is also possible with the \ntemporalsubset\n function:\n\n\nC = temporalsubset(C::ClimGrid, startdate::Date, enddate::Date)\n\n\n\n\n\n\nIndex\n\n\n\n\nClimateTools.ClimGrid\n\n\nClimateTools.ClimGrid\n\n\nBase.maximum\n\n\nBase.merge\n\n\nBase.minimum\n\n\nBase.std\n\n\nBase.var\n\n\nBase.vcat\n\n\nClimateTools.annualmax\n\n\nClimateTools.annualmax\n\n\nClimateTools.annualmax\n\n\nClimateTools.annualmean\n\n\nClimateTools.annualmean\n\n\nClimateTools.annualmin\n\n\nClimateTools.annualmin\n\n\nClimateTools.annualsum\n\n\nClimateTools.annualsum\n\n\nClimateTools.applymask\n\n\nClimateTools.buildtimevec\n\n\nClimateTools.customthresover\n\n\nClimateTools.customthresover\n\n\nClimateTools.customthresunder\n\n\nClimateTools.customthresunder\n\n\nClimateTools.daysabove10\n\n\nClimateTools.daysabove10\n\n\nClimateTools.frostdays\n\n\nClimateTools.frostdays\n\n\nClimateTools.icingdays\n\n\nClimateTools.icingdays\n\n\nClimateTools.inpoly\n\n\nClimateTools.inpolygrid\n\n\nClimateTools.interp_climgrid\n\n\nClimateTools.interp_climgrid\n\n\nClimateTools.mapclimgrid\n\n\nClimateTools.mapclimgrid\n\n\nClimateTools.mapclimgrid\n\n\nClimateTools.meshgrid\n\n\nClimateTools.nc2julia\n\n\nClimateTools.ndgrid\n\n\nClimateTools.pr_timefactor\n\n\nClimateTools.prcp1\n\n\nClimateTools.prcp1\n\n\nClimateTools.qqmap\n\n\nClimateTools.qqmap\n\n\nClimateTools.shapefile_coords\n\n\nClimateTools.shapefile_coords_poly\n\n\nClimateTools.spatialsubset\n\n\nClimateTools.sumleapyear\n\n\nClimateTools.summerdays\n\n\nClimateTools.summerdays\n\n\nClimateTools.temporalsubset\n\n\nClimateTools.timeindex\n\n\nClimateTools.timeresolution\n\n\nClimateTools.tropicalnights\n\n\nClimateTools.tropicalnights\n\n\nClimateTools.windnr\n\n\n\n\n\u2013", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#reading-a-netcdf-file", 
            "text": "The entry point of  ClimateTools  is to load data with the  nc2julia  function. Optional polygon clipping feature is available. By providing such polygon, the  nc2julia  function  returns a  ClimGrid  with grid points contained in the polygon.  C = nc2julia(filename::String, var::String; poly::Array, data_units::String, start_date::Date, end_date::Date)  nc2julia  return a  ClimGrid  type. Using the optional  poly  argument, the user can provide a polygon and the returned  ClimGrid  will only contains the grid points inside the provided polygon. The polygon provided should be in the -180, +180 longitude format. If the polygon crosses the International Date Line, the polygon should be splitted in multiple parts (i.e. multi-polygons).  For some variable, the optional keyword argument  data_units  can be provided. For example, precipitation in climate models are usually provided as  kg/m^2/s . By specifying  data_units = mm , the  nc2julia  function returns accumulation at the data time resolution. Similarly, the user can provide  Celsius  as  data_units  and  nc2julia  will return  Celsius  instead of  Kelvin .  The  ClimGrid  is a in-memory representation of a CF-compliant netCDF file for a single variable.  struct ClimGrid{A  : AxisArray}\n# struct ClimGrid\n  data::A\n  longrid::AbstractArray{N,2} where N # the longitude grid\n  latgrid::AbstractArray{N,2} where N # the latitude grid\n  msk::Array{N, 2} where N\n  grid_mapping::Dict#{String, Any} # bindings for native grid\n  dimension_dict::Dict\n  model::String\n  frequency::String\n  experiment::String\n  run::String\n  project::String # CORDEX, CMIP5, etc.\n  institute::String\n  filename::String\n  dataunits::String\n  latunits::String # of the coordinate variable\n  lonunits::String # of the coordinate variable\n  variable::String # Type of variable (i.e. can be the same as  var , but it is changed when calculating indices)\n  typeofvar::String # Variable type (e.g. tasmax, tasmin, pr)\n  typeofcal::String # Calendar type\n  varattribs::Dict # Variable attributes\n  globalattribs::Dict # Global attributes\n\nend  There is a  spatialsubset  function which acts on  ClimGrid  type and further subset the data through a spatial subset using a provided polygon. The function returns a  ClimGrid .  Polygons needs to be on a -180, +180 longitude coordinates, as data coordinates defaults to such grid.  For instance, global models are often on a 0-360 degrees grid.  C = spatialsubset(C::ClimGrid, poly:Array{N, 2} where N)  Temporal subset of the data is also possible with the  temporalsubset  function:  C = temporalsubset(C::ClimGrid, startdate::Date, enddate::Date)", 
            "title": "Reading a NetCDF file"
        }, 
        {
            "location": "/gettingstarted/#index", 
            "text": "ClimateTools.ClimGrid  ClimateTools.ClimGrid  Base.maximum  Base.merge  Base.minimum  Base.std  Base.var  Base.vcat  ClimateTools.annualmax  ClimateTools.annualmax  ClimateTools.annualmax  ClimateTools.annualmean  ClimateTools.annualmean  ClimateTools.annualmin  ClimateTools.annualmin  ClimateTools.annualsum  ClimateTools.annualsum  ClimateTools.applymask  ClimateTools.buildtimevec  ClimateTools.customthresover  ClimateTools.customthresover  ClimateTools.customthresunder  ClimateTools.customthresunder  ClimateTools.daysabove10  ClimateTools.daysabove10  ClimateTools.frostdays  ClimateTools.frostdays  ClimateTools.icingdays  ClimateTools.icingdays  ClimateTools.inpoly  ClimateTools.inpolygrid  ClimateTools.interp_climgrid  ClimateTools.interp_climgrid  ClimateTools.mapclimgrid  ClimateTools.mapclimgrid  ClimateTools.mapclimgrid  ClimateTools.meshgrid  ClimateTools.nc2julia  ClimateTools.ndgrid  ClimateTools.pr_timefactor  ClimateTools.prcp1  ClimateTools.prcp1  ClimateTools.qqmap  ClimateTools.qqmap  ClimateTools.shapefile_coords  ClimateTools.shapefile_coords_poly  ClimateTools.spatialsubset  ClimateTools.sumleapyear  ClimateTools.summerdays  ClimateTools.summerdays  ClimateTools.temporalsubset  ClimateTools.timeindex  ClimateTools.timeresolution  ClimateTools.tropicalnights  ClimateTools.tropicalnights  ClimateTools.windnr   \u2013", 
            "title": "Index"
        }, 
        {
            "location": "/indices/", 
            "text": "Indices in ClimateTools package (WIP)\n\n\n\n\nIndices\n\n\nMore than 20 climate indices are available in the package, such as the annual number of tropical nights, annual maximum and minimum, etc. You can calculate such indices simply with:\n\n\nind = annualmax(C::ClimGrid)\n\n\n\n\nWhich returns another \nClimGrid\n. You can also map this \nClimGrid\n with the \nmapclimgrid\n function and returns the climatological mean of the annual maximum (e.g. daily precipitation in the example below). A list of indices can be found in the documentation and in the \nfunctions.jl\n source code.\n\n\n   \n \n\n\n\nClimate Indices functions also accept other type of argument. For example, \nannualmax\n can be called with the following type:\n\n\nind = annualmax(data::Array{Float64, 3}, dates::StepRange{Date, Base.Dates.Day})\n\n\n\n\n\n\nAnnual indices\n\n\n#\n\n\nClimateTools.annualmax\n \n \nFunction\n.\n\n\nannualmax(C::ClimGrid)\n\n\n\n\nAnnual maximum of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.\n\n\nsource\n\n\nannualmax(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})\n\n\n\n\nAnnual maximum of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.\n\n\nsource\n\n\n\n\nSeasonal indices\n\n\nComing soon.", 
            "title": "Climate indices"
        }, 
        {
            "location": "/indices/#indices-in-climatetools-package-wip", 
            "text": "", 
            "title": "Indices in ClimateTools package (WIP)"
        }, 
        {
            "location": "/indices/#indices", 
            "text": "More than 20 climate indices are available in the package, such as the annual number of tropical nights, annual maximum and minimum, etc. You can calculate such indices simply with:  ind = annualmax(C::ClimGrid)  Which returns another  ClimGrid . You can also map this  ClimGrid  with the  mapclimgrid  function and returns the climatological mean of the annual maximum (e.g. daily precipitation in the example below). A list of indices can be found in the documentation and in the  functions.jl  source code.         Climate Indices functions also accept other type of argument. For example,  annualmax  can be called with the following type:  ind = annualmax(data::Array{Float64, 3}, dates::StepRange{Date, Base.Dates.Day})", 
            "title": "Indices"
        }, 
        {
            "location": "/indices/#annual-indices", 
            "text": "#  ClimateTools.annualmax     Function .  annualmax(C::ClimGrid)  Annual maximum of array data.  Let data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.  source  annualmax(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})  Annual maximum of array data.  Let data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.  source", 
            "title": "Annual indices"
        }, 
        {
            "location": "/indices/#seasonal-indices", 
            "text": "Coming soon.", 
            "title": "Seasonal indices"
        }, 
        {
            "location": "/interpolation/", 
            "text": "Interpolation\n\n\nA typical step in climate analysis is to interpolate a given grid onto another grid. \nClimateTools\n provides such a tool by wrapping Scipy griddata function. It is intended for visualization or as a 1st step before bias-correcting the \nClimGrid\n dataset.\n\n\nThe following command will interpolate the data contained in \nClimGrid A\n into the coordinates of \nClimGrid B\n and returns a new \nClimGrid C\n which contains the interpolated data of \nA\n into the grid of \nB\n.\n\n\nC = interp_climgrid(A::ClimGrid, B::ClimGrid)\n\n\n\n\nIt is also possible to interpolate a \nClimGrid\n onto specified longitude and latitude vectors.\n\n\nC = interp_climgrid(A::ClimGrid, lon::AbstractArray{N, 1}, lat::AbstractArray{N, 1})", 
            "title": "Interpolation"
        }, 
        {
            "location": "/interpolation/#interpolation", 
            "text": "A typical step in climate analysis is to interpolate a given grid onto another grid.  ClimateTools  provides such a tool by wrapping Scipy griddata function. It is intended for visualization or as a 1st step before bias-correcting the  ClimGrid  dataset.  The following command will interpolate the data contained in  ClimGrid A  into the coordinates of  ClimGrid B  and returns a new  ClimGrid C  which contains the interpolated data of  A  into the grid of  B .  C = interp_climgrid(A::ClimGrid, B::ClimGrid)  It is also possible to interpolate a  ClimGrid  onto specified longitude and latitude vectors.  C = interp_climgrid(A::ClimGrid, lon::AbstractArray{N, 1}, lat::AbstractArray{N, 1})", 
            "title": "Interpolation"
        }, 
        {
            "location": "/biascorrection/", 
            "text": "Bias correction\n\n\nQuantile-quantile mapping (Theme\u00dfl et al. 2012, Grenier et al. 2015) is provided with ClimateTools.jl through the function \nqqmap\n.\n\n\nqqmap(obs::ClimGrid, ref::ClimGrid, fut::ClimGrid; method::String=\nAdditive\n, detrend::Bool=true, window::Int=15, rankn::Int=50, thresnan::Float64=0.1, keep_original::Bool=false, interp = Linear(), extrap = Flat())\n\n\n\n\nMore information can be found in these references.\n\n\nTheme\u00dfl, Matthias Jakob, Andreas Gobiet, and Georg Heinrich. 2012. \u201cEmpirical-Statistical Downscaling and Error Correction of Regional Climate Models and Its Impact on the Climate Change Signal.\u201d Climatic Change 112 (2). Springer: 449\u201368.\n\n\nGrenier, Patrick, Ram\u00f3n de El\u00eda, and Diane Chaumont. 2015. \u201cChances of Short-Term Cooling Estimated from a Selection of CMIP5-Based Climate Scenarios during 2006-2035 over Canada.\u201d Journal of Climate, January 2015. American Meteorological Society. doi:10.1175/JCLI-D-14-00224.1.", 
            "title": "Bias correction"
        }, 
        {
            "location": "/biascorrection/#bias-correction", 
            "text": "Quantile-quantile mapping (Theme\u00dfl et al. 2012, Grenier et al. 2015) is provided with ClimateTools.jl through the function  qqmap .  qqmap(obs::ClimGrid, ref::ClimGrid, fut::ClimGrid; method::String= Additive , detrend::Bool=true, window::Int=15, rankn::Int=50, thresnan::Float64=0.1, keep_original::Bool=false, interp = Linear(), extrap = Flat())  More information can be found in these references.  Theme\u00dfl, Matthias Jakob, Andreas Gobiet, and Georg Heinrich. 2012. \u201cEmpirical-Statistical Downscaling and Error Correction of Regional Climate Models and Its Impact on the Climate Change Signal.\u201d Climatic Change 112 (2). Springer: 449\u201368.  Grenier, Patrick, Ram\u00f3n de El\u00eda, and Diane Chaumont. 2015. \u201cChances of Short-Term Cooling Estimated from a Selection of CMIP5-Based Climate Scenarios during 2006-2035 over Canada.\u201d Journal of Climate, January 2015. American Meteorological Society. doi:10.1175/JCLI-D-14-00224.1.", 
            "title": "Bias correction"
        }, 
        {
            "location": "/maps/", 
            "text": "Maps\n\n\n\n\nMapping the ClimGrid type\n\n\nMapping climate information can be done by using \nmapclimgrid\n.\n\n\n#\n\n\nClimateTools.mapclimgrid\n \n \nFunction\n.\n\n\nmapclimgrid(C::ClimGrid; region::String=\nauto\n, poly, level, mask, caxis, start_date::Date, end_date::Date)\n\n\n\n\nMaps the time-mean average of ClimGrid C.\n\n\nOptional keyworkd includes precribed regions (see list below), spatial clipping by polygon (keyword \npoly\n) or mask (keyword \nmask\n, an array of NaNs and 1.0 of the same dimension as the data in ClimGrid C), start_date and end_date.\n\n\nArguments\n\n\nRegions\n\n\n\n\nEurope\n\n\nNorthAmerica\n\n\nCanada\n\n\nQuebec, QuebecNSP\n\n\nAmericas\n\n\nWorld, WorldAz, WorldEck4\n\n\nGreenwich\n\n\n\n\nsource\n\n\nmapclimgrid(; region::String=\nauto\n, poly, level, mask, caxis, start_date::Date, end_date::Date)\n\n\n\n\nEmpty map generator, when called without a ClimGrid as the positional argument.\n\n\nsource\n\n\n   \n \n\n\n\nNote that the function plots the climatological mean of the provided \nClimGrid\n. Multiple options are available for region: \nWorld\n, \nCanada\n, \nQuebec\n and the default \nauto\n which use the maximum and minimum of the lat-long coordinates inside the \nClimGrid\n structure. The user can also provide a polygon(s) and the \nmapclimgrid\n function will clip the grid points outside the specified polygon. Another option is to provide a mask (with dimensions identical to the spatial dimension of the \nClimGrid\n data) which contains \nNaN\n and \n1.0\n and the data inside the \nClimGrid\n struct will be clipped with the mask. Other regions will be added in the future, as well as the option to send a custom region defined by a lat-lon box.", 
            "title": "Maps"
        }, 
        {
            "location": "/maps/#maps", 
            "text": "", 
            "title": "Maps"
        }, 
        {
            "location": "/maps/#mapping-the-climgrid-type", 
            "text": "Mapping climate information can be done by using  mapclimgrid .  #  ClimateTools.mapclimgrid     Function .  mapclimgrid(C::ClimGrid; region::String= auto , poly, level, mask, caxis, start_date::Date, end_date::Date)  Maps the time-mean average of ClimGrid C.  Optional keyworkd includes precribed regions (see list below), spatial clipping by polygon (keyword  poly ) or mask (keyword  mask , an array of NaNs and 1.0 of the same dimension as the data in ClimGrid C), start_date and end_date.  Arguments  Regions   Europe  NorthAmerica  Canada  Quebec, QuebecNSP  Americas  World, WorldAz, WorldEck4  Greenwich   source  mapclimgrid(; region::String= auto , poly, level, mask, caxis, start_date::Date, end_date::Date)  Empty map generator, when called without a ClimGrid as the positional argument.  source         Note that the function plots the climatological mean of the provided  ClimGrid . Multiple options are available for region:  World ,  Canada ,  Quebec  and the default  auto  which use the maximum and minimum of the lat-long coordinates inside the  ClimGrid  structure. The user can also provide a polygon(s) and the  mapclimgrid  function will clip the grid points outside the specified polygon. Another option is to provide a mask (with dimensions identical to the spatial dimension of the  ClimGrid  data) which contains  NaN  and  1.0  and the data inside the  ClimGrid  struct will be clipped with the mask. Other regions will be added in the future, as well as the option to send a custom region defined by a lat-lon box.", 
            "title": "Mapping the ClimGrid type"
        }, 
        {
            "location": "/interface/", 
            "text": "Interface\n\n\n\n\nMerging ClimGrid type\n\n\nSometimes, the timeseries are split among multiple files (e.g. climate models outputs). To obtain the complete timeseries, you can \nmerge\n 2 \nClimGrid\n. The method is based on the merging of 2 \nAxisArrays\n and is overloaded for the \nClimGrid\n type.\n\n\nC = merge(C1::ClimGrid, C2::ClimGrid)\n\n\n\n\n\n\nOperators\n\n\nBasic operators are overloaded on \nClimGrid\n.\n\n\nminimum", 
            "title": "Interface"
        }, 
        {
            "location": "/interface/#interface", 
            "text": "", 
            "title": "Interface"
        }, 
        {
            "location": "/interface/#merging-climgrid-type", 
            "text": "Sometimes, the timeseries are split among multiple files (e.g. climate models outputs). To obtain the complete timeseries, you can  merge  2  ClimGrid . The method is based on the merging of 2  AxisArrays  and is overloaded for the  ClimGrid  type.  C = merge(C1::ClimGrid, C2::ClimGrid)", 
            "title": "Merging ClimGrid type"
        }, 
        {
            "location": "/interface/#operators", 
            "text": "Basic operators are overloaded on  ClimGrid .  minimum", 
            "title": "Operators"
        }, 
        {
            "location": "/examples/", 
            "text": "Typical workflow for a climate scenario\n\n\nNote. Climate data can be downloaded at \nESGF nodes\n\n\nNote 2. The following example is somewhat convoluted, but it gives an overview of the main steps allowed by ClimateTools package.\n\n\n\n\nExploration\n\n\nFirst step before extracting the data is to explore the actual dataset at hand. The function \nDataset\n (reexported from te NCDatasets.jl package) is used to examine the file(s). In this example, the simulation is from the MIROC5 model.\n\n\njulia\n Dataset(\ndatafile.nc\n)\n\nDataset: /path/to/file/tasmax_day_MIROC5_historical_r1i1p1_19900101-19991231.nc\nGroup: /\n\nDimensions\n   time = 3650\n   lat = 128\n   lon = 256\n   bnds = 2\n\nVariables\n  time   (3650)\n    Datatype:    Float64\n    Dimensions:  time\n    Attributes:\n     bounds               = time_bnds\n     units                = days since 1850-1-1\n     calendar             = noleap\n     axis                 = T\n     long_name            = time\n     standard_name        = time\n\n  time_bnds   (2 \u00d7 3650)\n    Datatype:    Float64\n    Dimensions:  bnds \u00d7 time\n\n  lat   (128)\n    Datatype:    Float64\n    Dimensions:  lat\n    Attributes:\n     bounds               = lat_bnds\n     units                = degrees_north\n     axis                 = Y\n     long_name            = latitude\n     standard_name        = latitude\n\n  lat_bnds   (2 \u00d7 128)\n    Datatype:    Float64\n    Dimensions:  bnds \u00d7 lat\n\n  lon   (256)\n    Datatype:    Float64\n    Dimensions:  lon\n    Attributes:\n     bounds               = lon_bnds\n     units                = degrees_east\n     axis                 = X\n     long_name            = longitude\n     standard_name        = longitude\n\n  lon_bnds   (2 \u00d7 256)\n    Datatype:    Float64\n    Dimensions:  bnds \u00d7 lon\n\n  height  \n    Attributes:\n     units                = m\n     axis                 = Z\n     positive             = up\n     long_name            = height\n     standard_name        = height\n\n  tasmax   (256 \u00d7 128 \u00d7 3650)\n    Datatype:    Float32\n    Dimensions:  lon \u00d7 lat \u00d7 time\n    Attributes:\n     standard_name        = air_temperature\n     long_name            = Daily Maximum Near-Surface Air Temperature\n     units                = K\n     original_name        = T2\n     cell_methods         = time: maximum\n     cell_measures        = area: areacella\n     history              = 2011-10-19T12:39:31Z altered by CMOR: Treated scalar dimension: 'height'. 2011-10-19T12:39:31Z altered by CMOR: replaced missing value flag (-999) with standard missing value (1e+20). 2011-10-19T12:39:31Z altered by CMOR: Inverted axis: lat.\n     coordinates          = height\n     missing_value        = 1.0e20\n     _FillValue           = 1.0e20\n     associated_files     = baseURL: http://cmip-pcmdi.llnl.gov/CMIP5/dataLocation gridspecFile: gridspec_atmos_fx_MIROC5_historical_r0i0p0.nc areacella: areacella_fx_MIROC5_historical_r0i0p0.nc\n\nGlobal attributes\n  institution          = AORI (Atmosphere and Ocean Research Institute, The University of Tokyo, Chiba, Japan), NIES (National Institute for Environmental Studies, Ibaraki, Japan), JAMSTEC (Japan Agency for Marine-Earth Science and Technology, Kanagawa, Japan)\n  institute_id         = MIROC\n  experiment_id        = historical\n  source               = MIROC5 2010 atmosphere: MIROC-AGCM6 (T85L40); ocean: COCO (COCO4.5, 256x224 L50); sea ice: COCO (COCO4.5); land: MATSIRO (MATSIRO, L6); aerosols: SPRINTARS (SPRINTARS 5.00, T85L40)\n  model_id             = MIROC5\n  forcing              = GHG, SA, Oz, LU, Sl, Vl, SS, Ds, BC, MD, OC (GHG includes CO2, N2O, methane, and fluorocarbons; Oz includes OH and H2O2; LU excludes change in lake fraction)\n  parent_experiment_id = piControl\n  parent_experiment_rip = r1i1p1\n  branch_time          = 150015.0\n  contact              = Masahiro Watanabe (hiro@aori.u-tokyo.ac.jp), Seita Emori (emori@nies.go.jp), Masayoshi Ishii (ism@jamstec.go.jp), Masahide Kimoto (kimoto@aori.u-tokyo.ac.jp)\n  references           = Watanabe et al., 2010: Improved climate simulation by MIROC5: Mean states, variability, and climate sensitivity. J. Climate, 23, 6312-6335\n  initialization_method = 1\n  physics_version      = 1\n  tracking_id          = 54e617f1-31a5-47fd-bd57-8736bb7d00ef\n  product              = output\n  experiment           = historical\n  frequency            = day\n  creation_date        = 2011-10-19T12:39:31Z\n  history              = 2011-10-19T12:39:31Z CMOR rewrote data to comply with CF standards and CMIP5 requirements.\n  Conventions          = CF-1.4\n  project_id           = CMIP5\n  table_id             = Table day (26 July 2011) f21c16b785432e6bd3f72e80f2cade49\n  title                = MIROC5 model output prepared for CMIP5 historical\n  parent_experiment    = pre-industrial control\n  modeling_realm       = atmos\n  realization          = 1\n  cmor_version         = 2.7.1\n\n\n\n\n\nYou can see the dimensions of the data, as well as the name of the variable(s), in this case \"tasmax\".\n\n\n\n\nExtraction\n\n\nNow, say you need to create a climate scenario, using a given simulation, over a region defined by the following polygon.\n\n\njulia\n poly_reg = [[NaN -65 -80 -80 -65 -65];[NaN 42 42 52 52 42]]\n2\u00d76 Array{Float64,2}:\n NaN  -65.0  -80.0  -80.0  -65.0  -65.0\n NaN   42.0   42.0   52.0   52.0   42.0\n\n\n\n\nThe extraction of the desired variable can be done with the \nnc2julia\n function, by providing the polygon.\n\n\njulia\n gcmfiles =[\ntasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc\n,\n\ntasmax_day_MIROC5_historical_r1i1p1_19900101-19991231.nc\n,\n\ntasmax_day_MIROC5_historical_r1i1p1_20000101-20091231.nc\n]\n\njulia\n model = nc2julia(gcm_files, \ntasmax\n, poly=poly_reg)\nClimGrid struct with data:\n   3-dimensional AxisArray{Float32,3,...} with axes:\n    :time, Date[1980-01-01, 1980-01-02, 1980-01-03, 1980-01-04, 1980-01-05, 1980-01-06, 1980-01-07, 1980-01-08, 1980-01-09, 1980-01-10  \u2026  2009-12-22, 2009-12-23, 2009-12-24, 2009-12-25, 2009-12-26, 2009-12-27, 2009-12-28, 2009-12-29, 2009-12-30, 2009-12-31]\n    :lon, [-78.75, -77.3438, -75.9375, -74.5313, -73.125, -71.7188, -70.3125, -68.9063, -67.5, -66.0938]\n    :lat, [42.7233, 44.1241, 45.5249, 46.9256, 48.3264, 49.7271, 51.1279]\nAnd data, a 10950\u00d710\u00d77 Array{Float32,3}\nProject: CMIP5\nInstitute: MIROC\nModel: MIROC5\nExperiment: historical\nRun: r1i1p1\nVariable: tasmax\nData units: K\nFrequency: day\nGlobal attributes: Dict{Any,Any} with 27 entries\nFilename: tasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc\n\n\n\n\nOne possible verification of the extraced data is to map the time-mean data with the \nmapclimgrid\n function to see if there is something wrong.\n\n\njulia\n mapclimgrid(model, region = \nQuebec\n)\n\n\n\n\nWhich should return the following map.\n\n\n   \n \n\n\n\n\n\nSidenote: merging files/data\n\n\nAs a sidenote, climate data files are usually on the order of multiple GBs and institution generally split a single simulation into multiple files. In order to calculate climatologies, it is thus essential to merge the data into a single structure. The function \nmerge\n is provided to combine 2 \nClimGrid\n.\n\n\njulia\n C = merge(C1, C2) # merge C1 with C2\n\n\n\n\nThe \nmerge\n function is useful when you have 2 or 3 files. However, a single simulation can sometimes be splitted into yearly files. Hence, extracting timeseries on climatological timescales can imply loading more than a hundred files just to get a complete timeserie for a given gridpoint. The function \nnc2julia\n has a method where the 1st positional argument is an Array of strings (as opposed to a single string).\n\n\njulia\n C = nc2julia(strarray::Array{String,1}, variable::String; poly, start_date::Date, end_date::Date, data_units::String))\n\n\n\n\nThis is how the MIROC5 simulation has been loaded.\n\n\n\n\nBias correction\n\n\nAn important step in climate scenarios design is to correct the statistical bias of the simulations compared against a chosen reference (more often than not, weather observations). A typical method is to do quantile-quantile mapping between the simulation timeseries and observed timeseries. The function \nqqmap\n does so. First step would be to interpolate the simulated field onto the reference grid. Here we use the dataset provided by the Canadian Forest Service (https://cfs.nrcan.gc.ca/projects/3/4, see McKenney et al. 2011) for the interpolation step and the bias correction step.\n\n\nMcKenney, D. W., Hutchinson, M.F., Papadopol, P., Lawrence, K., Pedlar, J., Campbell, K., Milewska, E., Hopkinson, R., Price, D., Owen, T. (2011). \"Customized spatial climate models for North America.\" Bulletin of American Meteorological Society-BAMS December: 1612-1622.\n\n\njulia\n obsfiles = [\nnrcan_canada_daily_tasmax_1950.nc\n,\n\nnrcan_canada_daily_tasmax_1951.nc\n,\n\nnrcan_canada_daily_tasmax_1952.nc\n,\n\nnrcan_canada_daily_tasmax_1953.nc\n,\n\nnrcan_canada_daily_tasmax_1954.nc\n,\n\nnrcan_canada_daily_tasmax_1955.nc\n,\n\nnrcan_canada_daily_tasmax_1956.nc\n,\n\nnrcan_canada_daily_tasmax_1957.nc\n,\n\nnrcan_canada_daily_tasmax_1958.nc\n,\n\nnrcan_canada_daily_tasmax_1959.nc\n,\n\nnrcan_canada_daily_tasmax_1960.nc\n,\n\nnrcan_canada_daily_tasmax_1961.nc\n,\n\nnrcan_canada_daily_tasmax_1962.nc\n,\n\nnrcan_canada_daily_tasmax_1963.nc\n,\n\nnrcan_canada_daily_tasmax_1964.nc\n,\n\nnrcan_canada_daily_tasmax_1965.nc\n,\n\nnrcan_canada_daily_tasmax_1966.nc\n,\n\nnrcan_canada_daily_tasmax_1967.nc\n,\n\nnrcan_canada_daily_tasmax_1968.nc\n,\n\nnrcan_canada_daily_tasmax_1969.nc\n]\n\njulia\n obs = nc2julia(obsfiles, \ntasmax\n, poly=poly_reg)\n\n\n\n\njulia\n mapclimgrid(obs, region = \nQuebec\n)\n\n\n\n\n   \n \n\n\n\n\n\nInterpolation\n\n\nThe interpolation is done with the \ninterp_climgrid\n function. The following command interpolate the values of \nClimGrid model\n onto the grid of \nClimGrid obs\n.\n\n\njulia\n modelinterp = interp_climgrid(model, obs)\nProgress: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| Time: 0:00:38\nClimGrid struct with data:\n   3-dimensional AxisArray{Float64,3,...} with axes:\n    :time, Date[1980-01-01, 1980-01-02, 1980-01-03, 1980-01-04, 1980-01-05, 1980-01-06, 1980-01-07, 1980-01-08, 1980-01-09, 1980-01-10  \u2026  2009-12-22, 2009-12-23, 2009-12-24, 2009-12-25, 2009-12-26, 2009-12-27, 2009-12-28, 2009-12-29, 2009-12-30, 2009-12-31]\n    :lon, Float32[-79.9583, -79.875, -79.7917, -79.7083, -79.625, -79.5417, -79.4583, -79.375, -79.2917, -79.2083  \u2026  -65.7917, -65.7083, -65.625, -65.5417, -65.4583, -65.375, -65.2917, -65.2083, -65.125, -65.0417]\n    :lat, Float32[51.9583, 51.875, 51.7917, 51.7083, 51.625, 51.5417, 51.4583, 51.375, 51.2917, 51.2083  \u2026  42.7917, 42.7083, 42.625, 42.5417, 42.4583, 42.375, 42.2917, 42.2083, 42.125, 42.0417]\nAnd data, a 10950\u00d7180\u00d7120 Array{Float64,3}\nProject: CMIP5\nInstitute: MIROC\nModel: MIROC5\nExperiment: historical\nRun: r1i1p1\nVariable: tasmax\nData units: K\nFrequency: day\nGlobal attributes: Dict{Any,Any} with 27 entries\nFilename: tasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc\n\n\n\n\njulia\n mapclimgrid(modelinterp, region = \nQuebec\n)\n\n\n\n\n   \n \n\n\n\nNotice that there is no new information created here. The interpolation is using Scipy's griddata under the hood and is simply a linear interpolation onto the \nobs\n grid.\n\n\n\n\nQuantile-quantile mapping\n\n\nThe high-resolution local information is integrated into \nClimGrid modelinterp\n at the bias correction step. There is a daily transfer function applied on a quantile basis.The call signature is \nqqmap(obs, ref, fut)\n where the transfer function is estimated between \nobs\n and \nref\n and applied on \nfut\n. Note that \nref\n and \nfut\n can be the same, as in this example. A typical use-case would be \nobs\n and \nref\n covering the same (historical, e.g. 1961-2010) temporal window and \nfut\n being a simulation covering a future climatological period (which could be a mix of historic and future, such as 1961-2090). This step is computationally intensive.\n\n\njulia\n model_qqmap = qqmap(obs, modelinterp, modelinterp)\nProgress: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| Time: 0:11:20\nClimGrid struct with data:\n   3-dimensional AxisArray{Float64,3,...} with axes:\n    :time, Date[1980-01-01, 1980-01-02, 1980-01-03, 1980-01-04, 1980-01-05, 1980-01-06, 1980-01-07, 1980-01-08, 1980-01-09, 1980-01-10  \u2026  2009-12-22, 2009-12-23, 2009-12-24, 2009-12-25, 2009-12-26, 2009-12-27, 2009-12-28, 2009-12-29, 2009-12-30, 2009-12-31]\n    :lon, Float32[-79.9583, -79.875, -79.7917, -79.7083, -79.625, -79.5417, -79.4583, -79.375, -79.2917, -79.2083  \u2026  -65.7917, -65.7083, -65.625, -65.5417, -65.4583, -65.375, -65.2917, -65.2083, -65.125, -65.0417]\n    :lat, Float32[51.9583, 51.875, 51.7917, 51.7083, 51.625, 51.5417, 51.4583, 51.375, 51.2917, 51.2083  \u2026  42.7917, 42.7083, 42.625, 42.5417, 42.4583, 42.375, 42.2917, 42.2083, 42.125, 42.0417]\nAnd data, a 10950\u00d7180\u00d7120 Array{Float64,3}\nProject: CMIP5\nInstitute: MIROC\nModel: MIROC5\nExperiment: historical\nRun: r1i1p1\nVariable: tasmax\nData units: K\nFrequency: NA\nGlobal attributes: Dict{Any,Any} with 0 entries\nFilename: tasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc\n\n\n\n\nMapping the results show that the local information is integrated into the model, and that the natural \"mask\" of the observation grid is applied naturally.\n\n\njulia\n mapclimgrid(model_qqmap, region = \nQuebec\n)", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#typical-workflow-for-a-climate-scenario", 
            "text": "Note. Climate data can be downloaded at  ESGF nodes  Note 2. The following example is somewhat convoluted, but it gives an overview of the main steps allowed by ClimateTools package.", 
            "title": "Typical workflow for a climate scenario"
        }, 
        {
            "location": "/examples/#exploration", 
            "text": "First step before extracting the data is to explore the actual dataset at hand. The function  Dataset  (reexported from te NCDatasets.jl package) is used to examine the file(s). In this example, the simulation is from the MIROC5 model.  julia  Dataset( datafile.nc )\n\nDataset: /path/to/file/tasmax_day_MIROC5_historical_r1i1p1_19900101-19991231.nc\nGroup: /\n\nDimensions\n   time = 3650\n   lat = 128\n   lon = 256\n   bnds = 2\n\nVariables\n  time   (3650)\n    Datatype:    Float64\n    Dimensions:  time\n    Attributes:\n     bounds               = time_bnds\n     units                = days since 1850-1-1\n     calendar             = noleap\n     axis                 = T\n     long_name            = time\n     standard_name        = time\n\n  time_bnds   (2 \u00d7 3650)\n    Datatype:    Float64\n    Dimensions:  bnds \u00d7 time\n\n  lat   (128)\n    Datatype:    Float64\n    Dimensions:  lat\n    Attributes:\n     bounds               = lat_bnds\n     units                = degrees_north\n     axis                 = Y\n     long_name            = latitude\n     standard_name        = latitude\n\n  lat_bnds   (2 \u00d7 128)\n    Datatype:    Float64\n    Dimensions:  bnds \u00d7 lat\n\n  lon   (256)\n    Datatype:    Float64\n    Dimensions:  lon\n    Attributes:\n     bounds               = lon_bnds\n     units                = degrees_east\n     axis                 = X\n     long_name            = longitude\n     standard_name        = longitude\n\n  lon_bnds   (2 \u00d7 256)\n    Datatype:    Float64\n    Dimensions:  bnds \u00d7 lon\n\n  height  \n    Attributes:\n     units                = m\n     axis                 = Z\n     positive             = up\n     long_name            = height\n     standard_name        = height\n\n  tasmax   (256 \u00d7 128 \u00d7 3650)\n    Datatype:    Float32\n    Dimensions:  lon \u00d7 lat \u00d7 time\n    Attributes:\n     standard_name        = air_temperature\n     long_name            = Daily Maximum Near-Surface Air Temperature\n     units                = K\n     original_name        = T2\n     cell_methods         = time: maximum\n     cell_measures        = area: areacella\n     history              = 2011-10-19T12:39:31Z altered by CMOR: Treated scalar dimension: 'height'. 2011-10-19T12:39:31Z altered by CMOR: replaced missing value flag (-999) with standard missing value (1e+20). 2011-10-19T12:39:31Z altered by CMOR: Inverted axis: lat.\n     coordinates          = height\n     missing_value        = 1.0e20\n     _FillValue           = 1.0e20\n     associated_files     = baseURL: http://cmip-pcmdi.llnl.gov/CMIP5/dataLocation gridspecFile: gridspec_atmos_fx_MIROC5_historical_r0i0p0.nc areacella: areacella_fx_MIROC5_historical_r0i0p0.nc\n\nGlobal attributes\n  institution          = AORI (Atmosphere and Ocean Research Institute, The University of Tokyo, Chiba, Japan), NIES (National Institute for Environmental Studies, Ibaraki, Japan), JAMSTEC (Japan Agency for Marine-Earth Science and Technology, Kanagawa, Japan)\n  institute_id         = MIROC\n  experiment_id        = historical\n  source               = MIROC5 2010 atmosphere: MIROC-AGCM6 (T85L40); ocean: COCO (COCO4.5, 256x224 L50); sea ice: COCO (COCO4.5); land: MATSIRO (MATSIRO, L6); aerosols: SPRINTARS (SPRINTARS 5.00, T85L40)\n  model_id             = MIROC5\n  forcing              = GHG, SA, Oz, LU, Sl, Vl, SS, Ds, BC, MD, OC (GHG includes CO2, N2O, methane, and fluorocarbons; Oz includes OH and H2O2; LU excludes change in lake fraction)\n  parent_experiment_id = piControl\n  parent_experiment_rip = r1i1p1\n  branch_time          = 150015.0\n  contact              = Masahiro Watanabe (hiro@aori.u-tokyo.ac.jp), Seita Emori (emori@nies.go.jp), Masayoshi Ishii (ism@jamstec.go.jp), Masahide Kimoto (kimoto@aori.u-tokyo.ac.jp)\n  references           = Watanabe et al., 2010: Improved climate simulation by MIROC5: Mean states, variability, and climate sensitivity. J. Climate, 23, 6312-6335\n  initialization_method = 1\n  physics_version      = 1\n  tracking_id          = 54e617f1-31a5-47fd-bd57-8736bb7d00ef\n  product              = output\n  experiment           = historical\n  frequency            = day\n  creation_date        = 2011-10-19T12:39:31Z\n  history              = 2011-10-19T12:39:31Z CMOR rewrote data to comply with CF standards and CMIP5 requirements.\n  Conventions          = CF-1.4\n  project_id           = CMIP5\n  table_id             = Table day (26 July 2011) f21c16b785432e6bd3f72e80f2cade49\n  title                = MIROC5 model output prepared for CMIP5 historical\n  parent_experiment    = pre-industrial control\n  modeling_realm       = atmos\n  realization          = 1\n  cmor_version         = 2.7.1  You can see the dimensions of the data, as well as the name of the variable(s), in this case \"tasmax\".", 
            "title": "Exploration"
        }, 
        {
            "location": "/examples/#extraction", 
            "text": "Now, say you need to create a climate scenario, using a given simulation, over a region defined by the following polygon.  julia  poly_reg = [[NaN -65 -80 -80 -65 -65];[NaN 42 42 52 52 42]]\n2\u00d76 Array{Float64,2}:\n NaN  -65.0  -80.0  -80.0  -65.0  -65.0\n NaN   42.0   42.0   52.0   52.0   42.0  The extraction of the desired variable can be done with the  nc2julia  function, by providing the polygon.  julia  gcmfiles =[ tasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc , tasmax_day_MIROC5_historical_r1i1p1_19900101-19991231.nc , tasmax_day_MIROC5_historical_r1i1p1_20000101-20091231.nc ]\n\njulia  model = nc2julia(gcm_files,  tasmax , poly=poly_reg)\nClimGrid struct with data:\n   3-dimensional AxisArray{Float32,3,...} with axes:\n    :time, Date[1980-01-01, 1980-01-02, 1980-01-03, 1980-01-04, 1980-01-05, 1980-01-06, 1980-01-07, 1980-01-08, 1980-01-09, 1980-01-10  \u2026  2009-12-22, 2009-12-23, 2009-12-24, 2009-12-25, 2009-12-26, 2009-12-27, 2009-12-28, 2009-12-29, 2009-12-30, 2009-12-31]\n    :lon, [-78.75, -77.3438, -75.9375, -74.5313, -73.125, -71.7188, -70.3125, -68.9063, -67.5, -66.0938]\n    :lat, [42.7233, 44.1241, 45.5249, 46.9256, 48.3264, 49.7271, 51.1279]\nAnd data, a 10950\u00d710\u00d77 Array{Float32,3}\nProject: CMIP5\nInstitute: MIROC\nModel: MIROC5\nExperiment: historical\nRun: r1i1p1\nVariable: tasmax\nData units: K\nFrequency: day\nGlobal attributes: Dict{Any,Any} with 27 entries\nFilename: tasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc  One possible verification of the extraced data is to map the time-mean data with the  mapclimgrid  function to see if there is something wrong.  julia  mapclimgrid(model, region =  Quebec )  Which should return the following map.", 
            "title": "Extraction"
        }, 
        {
            "location": "/examples/#sidenote-merging-filesdata", 
            "text": "As a sidenote, climate data files are usually on the order of multiple GBs and institution generally split a single simulation into multiple files. In order to calculate climatologies, it is thus essential to merge the data into a single structure. The function  merge  is provided to combine 2  ClimGrid .  julia  C = merge(C1, C2) # merge C1 with C2  The  merge  function is useful when you have 2 or 3 files. However, a single simulation can sometimes be splitted into yearly files. Hence, extracting timeseries on climatological timescales can imply loading more than a hundred files just to get a complete timeserie for a given gridpoint. The function  nc2julia  has a method where the 1st positional argument is an Array of strings (as opposed to a single string).  julia  C = nc2julia(strarray::Array{String,1}, variable::String; poly, start_date::Date, end_date::Date, data_units::String))  This is how the MIROC5 simulation has been loaded.", 
            "title": "Sidenote: merging files/data"
        }, 
        {
            "location": "/examples/#bias-correction", 
            "text": "An important step in climate scenarios design is to correct the statistical bias of the simulations compared against a chosen reference (more often than not, weather observations). A typical method is to do quantile-quantile mapping between the simulation timeseries and observed timeseries. The function  qqmap  does so. First step would be to interpolate the simulated field onto the reference grid. Here we use the dataset provided by the Canadian Forest Service (https://cfs.nrcan.gc.ca/projects/3/4, see McKenney et al. 2011) for the interpolation step and the bias correction step.  McKenney, D. W., Hutchinson, M.F., Papadopol, P., Lawrence, K., Pedlar, J., Campbell, K., Milewska, E., Hopkinson, R., Price, D., Owen, T. (2011). \"Customized spatial climate models for North America.\" Bulletin of American Meteorological Society-BAMS December: 1612-1622.  julia  obsfiles = [ nrcan_canada_daily_tasmax_1950.nc , nrcan_canada_daily_tasmax_1951.nc , nrcan_canada_daily_tasmax_1952.nc , nrcan_canada_daily_tasmax_1953.nc , nrcan_canada_daily_tasmax_1954.nc , nrcan_canada_daily_tasmax_1955.nc , nrcan_canada_daily_tasmax_1956.nc , nrcan_canada_daily_tasmax_1957.nc , nrcan_canada_daily_tasmax_1958.nc , nrcan_canada_daily_tasmax_1959.nc , nrcan_canada_daily_tasmax_1960.nc , nrcan_canada_daily_tasmax_1961.nc , nrcan_canada_daily_tasmax_1962.nc , nrcan_canada_daily_tasmax_1963.nc , nrcan_canada_daily_tasmax_1964.nc , nrcan_canada_daily_tasmax_1965.nc , nrcan_canada_daily_tasmax_1966.nc , nrcan_canada_daily_tasmax_1967.nc , nrcan_canada_daily_tasmax_1968.nc , nrcan_canada_daily_tasmax_1969.nc ]\n\njulia  obs = nc2julia(obsfiles,  tasmax , poly=poly_reg)  julia  mapclimgrid(obs, region =  Quebec )", 
            "title": "Bias correction"
        }, 
        {
            "location": "/examples/#interpolation", 
            "text": "The interpolation is done with the  interp_climgrid  function. The following command interpolate the values of  ClimGrid model  onto the grid of  ClimGrid obs .  julia  modelinterp = interp_climgrid(model, obs)\nProgress: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| Time: 0:00:38\nClimGrid struct with data:\n   3-dimensional AxisArray{Float64,3,...} with axes:\n    :time, Date[1980-01-01, 1980-01-02, 1980-01-03, 1980-01-04, 1980-01-05, 1980-01-06, 1980-01-07, 1980-01-08, 1980-01-09, 1980-01-10  \u2026  2009-12-22, 2009-12-23, 2009-12-24, 2009-12-25, 2009-12-26, 2009-12-27, 2009-12-28, 2009-12-29, 2009-12-30, 2009-12-31]\n    :lon, Float32[-79.9583, -79.875, -79.7917, -79.7083, -79.625, -79.5417, -79.4583, -79.375, -79.2917, -79.2083  \u2026  -65.7917, -65.7083, -65.625, -65.5417, -65.4583, -65.375, -65.2917, -65.2083, -65.125, -65.0417]\n    :lat, Float32[51.9583, 51.875, 51.7917, 51.7083, 51.625, 51.5417, 51.4583, 51.375, 51.2917, 51.2083  \u2026  42.7917, 42.7083, 42.625, 42.5417, 42.4583, 42.375, 42.2917, 42.2083, 42.125, 42.0417]\nAnd data, a 10950\u00d7180\u00d7120 Array{Float64,3}\nProject: CMIP5\nInstitute: MIROC\nModel: MIROC5\nExperiment: historical\nRun: r1i1p1\nVariable: tasmax\nData units: K\nFrequency: day\nGlobal attributes: Dict{Any,Any} with 27 entries\nFilename: tasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc  julia  mapclimgrid(modelinterp, region =  Quebec )         Notice that there is no new information created here. The interpolation is using Scipy's griddata under the hood and is simply a linear interpolation onto the  obs  grid.", 
            "title": "Interpolation"
        }, 
        {
            "location": "/examples/#quantile-quantile-mapping", 
            "text": "The high-resolution local information is integrated into  ClimGrid modelinterp  at the bias correction step. There is a daily transfer function applied on a quantile basis.The call signature is  qqmap(obs, ref, fut)  where the transfer function is estimated between  obs  and  ref  and applied on  fut . Note that  ref  and  fut  can be the same, as in this example. A typical use-case would be  obs  and  ref  covering the same (historical, e.g. 1961-2010) temporal window and  fut  being a simulation covering a future climatological period (which could be a mix of historic and future, such as 1961-2090). This step is computationally intensive.  julia  model_qqmap = qqmap(obs, modelinterp, modelinterp)\nProgress: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| Time: 0:11:20\nClimGrid struct with data:\n   3-dimensional AxisArray{Float64,3,...} with axes:\n    :time, Date[1980-01-01, 1980-01-02, 1980-01-03, 1980-01-04, 1980-01-05, 1980-01-06, 1980-01-07, 1980-01-08, 1980-01-09, 1980-01-10  \u2026  2009-12-22, 2009-12-23, 2009-12-24, 2009-12-25, 2009-12-26, 2009-12-27, 2009-12-28, 2009-12-29, 2009-12-30, 2009-12-31]\n    :lon, Float32[-79.9583, -79.875, -79.7917, -79.7083, -79.625, -79.5417, -79.4583, -79.375, -79.2917, -79.2083  \u2026  -65.7917, -65.7083, -65.625, -65.5417, -65.4583, -65.375, -65.2917, -65.2083, -65.125, -65.0417]\n    :lat, Float32[51.9583, 51.875, 51.7917, 51.7083, 51.625, 51.5417, 51.4583, 51.375, 51.2917, 51.2083  \u2026  42.7917, 42.7083, 42.625, 42.5417, 42.4583, 42.375, 42.2917, 42.2083, 42.125, 42.0417]\nAnd data, a 10950\u00d7180\u00d7120 Array{Float64,3}\nProject: CMIP5\nInstitute: MIROC\nModel: MIROC5\nExperiment: historical\nRun: r1i1p1\nVariable: tasmax\nData units: K\nFrequency: NA\nGlobal attributes: Dict{Any,Any} with 0 entries\nFilename: tasmax_day_MIROC5_historical_r1i1p1_19800101-19891231.nc  Mapping the results show that the local information is integrated into the model, and that the natural \"mask\" of the observation grid is applied naturally.  julia  mapclimgrid(model_qqmap, region =  Quebec )", 
            "title": "Quantile-quantile mapping"
        }, 
        {
            "location": "/functions/", 
            "text": "Index\n\n\n#\n\n\nBase.maximum\n \n \nMethod\n.\n\n\nmaximum(A::ClimGrid)\n\n\n\n\nCompute the maximum value of \nClimGrid\n A\n\n\nsource\n\n\n#\n\n\nBase.minimum\n \n \nMethod\n.\n\n\nminimum(A::ClimGrid)\n\n\n\n\nCompute the minimum value of \nClimGrid\n A\n\n\nsource\n\n\n#\n\n\nBase.std\n \n \nMethod\n.\n\n\nstd(A::ClimGrid)\n\n\n\n\nCompute the standard deviation of \nClimGrid\n A\n\n\nsource\n\n\n#\n\n\nBase.var\n \n \nMethod\n.\n\n\nvar(A::ClimGrid)\n\n\n\n\nCompute the variance of \nClimGrid\n A\n\n\nsource\n\n\n#\n\n\nClimateTools.annualmax\n \n \nMethod\n.\n\n\nannualmax(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})\n\n\n\n\nAnnual maximum of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.\n\n\nsource\n\n\n#\n\n\nClimateTools.annualmax\n \n \nMethod\n.\n\n\nannualmax(C::ClimGrid)\n\n\n\n\nAnnual maximum of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.\n\n\nsource\n\n\n#\n\n\nClimateTools.annualmean\n \n \nMethod\n.\n\n\nannualmean(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})\n\n\n\n\nAnnual mean of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Calculate the mean value for year j.\n\n\nsource\n\n\n#\n\n\nClimateTools.annualmean\n \n \nMethod\n.\n\n\nannualmean(C::ClimGrid)\n\n\n\n\nAnnual mean of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Calculate the mean value for year j.\n\n\nsource\n\n\n#\n\n\nClimateTools.annualmin\n \n \nMethod\n.\n\n\nannualmin(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})\n\n\n\n\nAnnual minimum of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Extract the lowest value for year j.\n\n\nsource\n\n\n#\n\n\nClimateTools.annualmin\n \n \nMethod\n.\n\n\nannualmin(C::ClimGrid)\n\n\n\n\nAnnual minimum of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Extract the lowest value for year j.\n\n\nsource\n\n\n#\n\n\nClimateTools.annualsum\n \n \nMethod\n.\n\n\nannualsum(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})\n\n\n\n\nValue of annual sum of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Sums daily values for year j.\n\n\nsource\n\n\n#\n\n\nClimateTools.annualsum\n \n \nMethod\n.\n\n\nannualsum(C::ClimGrid)\n\n\n\n\nAnnual sum of array data.\n\n\nLet data[i,j] be daily time serie on day i in year j. Sums daily values for year j.\n\n\nsource\n\n\n#\n\n\nClimateTools.applymask\n \n \nMethod\n.\n\n\napplymask(A::AbstractArray{N, n}, mask::AbstractArray{N, n})\n\n\n\n\nThis function applies a mask on the array A. Return an AbstractArray{N, n}.\n\n\nsource\n\n\n#\n\n\nClimateTools.buildtimevec\n \n \nMethod\n.\n\n\nbuildtimevec(str::String)Y\n\n\n\n\nConstruct the time vector from the netCDF file str\n\n\nsource\n\n\n#\n\n\nClimateTools.customthresover\n \n \nMethod\n.\n\n\ncustomthresover(data::AbstractArray, time::StepRange{Date,Base.Dates.Day}, thres)\n\n\n\n\ncustomthresover, annual number of days over a specified threshold.\n\n\nLet TS[i,j] be a daily time serie value on day i in year j. Count the number of days where:\n\n\nTS[i,j] \n thres.\n\n\nsource\n\n\n#\n\n\nClimateTools.customthresover\n \n \nMethod\n.\n\n\ncustomthresover(C::ClimGrid)\n\n\n\n\ncustomthresover, annual number of days over a specified threshold.\n\n\nLet TS[i,j] be a daily time serie value on day i in year j. Count the number of days where:\n\n\nTS[i,j] \n thres.\n\n\nsource\n\n\n#\n\n\nClimateTools.customthresunder\n \n \nMethod\n.\n\n\ncustomthresunder(data::AbstractArray, time::StepRange{Date,Base.Dates.Day}, thres)\n\n\n\n\ncustomthresover, annual number of days under a specified threshold.\n\n\nLet TS[i,j] be a daily time serie value on day i in year j. Count the number of days where:\n\n\nTS[i,j] \n thres.\n\n\n\n\nsource\n\n\n#\n\n\nClimateTools.customthresunder\n \n \nMethod\n.\n\n\ncustomthresunder(C::ClimGrid)\n\n\n\n\ncustomthresover, annual number of days under a specified threshold.\n\n\nLet TS[i,j] be a daily time serie value on day i in year j. Count the number of days where:\n\n\nTS[i,j] \n thres.\n\n\nsource\n\n\n#\n\n\nClimateTools.daysabove10\n \n \nMethod\n.\n\n\ndaysabove10(data::AbstractArray, timevector::StepRange{Date,Base.Dates.Day})\n\n\n\n\nAnnual number with temperature \n= 10 Celsius. This function returns a boolean vector. \ntrue\n if the data is higher or equal to 1 and \nfalse\n otherwise.\n\n\nsource\n\n\n#\n\n\nClimateTools.daysabove10\n \n \nMethod\n.\n\n\ndaysabove10(C::ClimGrid)\n\n\n\n\nAnnual number of days with temperature \n= 10 Celsius. This function returns a ClimGrid.\n\n\nsource\n\n\n#\n\n\nClimateTools.frostdays\n \n \nMethod\n.\n\n\nfrostdays(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})\n\n\n\n\nFD, Number of frost days: Annual count of days when TN (daily minimum temperature) \n 0 Celsius.\n\n\nLet TN[i,j] be daily minimum temperature on day i in year j. Count the number of days where:\n\n\nTN[i,j] \n 0 Celsius.\n\n\nsource\n\n\n#\n\n\nClimateTools.frostdays\n \n \nMethod\n.\n\n\nfrostdays(C::ClimGrid)\n\n\n\n\nFD, Number of frost days: Annual count of days when TN (daily minimum temperature) \n 0 Celsius.\n\n\nLet TN[i,j] be daily minimum temperature on day i in year j. Count the number of days where:\n\n\nTN[i,j] \n 0 Celsius.\n\n\nsource\n\n\n#\n\n\nClimateTools.icingdays\n \n \nMethod\n.\n\n\nicingdays(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})\n\n\n\n\nID, Number of summer days: Annual count of days when TX (daily maximum temperature) \n 0 degree Celsius.\n\n\nLet TX[i,j] be daily maximum temperature on day i in year j. Count the number of days where:\n\n\nTX[i,j] \n 0 Celsius.\n\n\nsource\n\n\n#\n\n\nClimateTools.icingdays\n \n \nMethod\n.\n\n\nicingdays(C::ClimGrid)\n\n\n\n\nID, Number of summer days: Annual count of days when TX (daily maximum temperature) \n 0 degree Celsius.\n\n\nLet TX[i,j] be daily maximum temperature on day i in year j. Count the number of days where:\n\n\nTX[i,j] \n 0 Celsius.\n\n\nsource\n\n\n#\n\n\nClimateTools.inpoly\n \n \nMethod\n.\n\n\ninpoly(p, poly::Matrix)\n\n\n\n\nDetermines if a point is inside a polygon.\n\n\n\n\np \u2013 point (x,y) or [x,y]\n\n\npoly \u2013 polygon vertices \nx1 x2 ... xn x1                           y1 y2 ... yn y1\n\n\n\n\nReturns true if point has an odd winding number.  This should label points as exterior which are inside outcrops.  See test for a test.\n\n\nAuthor: Github \"Mauro3\" / \"Mauro\"\n\n\nsource\n\n\n#\n\n\nClimateTools.inpolygrid\n \n \nMethod\n.\n\n\ninpolygrid(lon, lat, poly::AbstractArray{N,2} where N)\n\n\n\n\nUsed to test a grid of points. Returns a mask of ones and NaNs of the same size as lon and lat.\n\n\nsource\n\n\n#\n\n\nClimateTools.interp_climgrid\n \n \nMethod\n.\n\n\nC = interp_climgrid(A::ClimGrid, londest::AbstractArray{N, 1} where N, latdest::AbstractArray{N, 1} where N)A\n\n\n\n\nThis function interpolate ClimGrid A onto lat-lon grid defined by londest and latdest vector.\n\n\nsource\n\n\n#\n\n\nClimateTools.interp_climgrid\n \n \nMethod\n.\n\n\nC = interp_climgrid(A::ClimGrid, B::ClimGrid; method=\nlinear\n, min=[], max=[])\n\n\n\n\nThis function interpolate \nClimGrid\n A onto the lon-lat grid of \nClimGrid\n B, where A and B are \nClimGrid\n. Available methods for interpolation are \"linear\" (default), \"nearest\" and \"cubic\".\n\n\nMin and max optional keyword are used to constraint the results of the interpolation. For example, interpolating bounded fields can lead to unrealilstic values, such as negative precipitation. In that case, one would use min=0.0 to convert negative precipitation to 0.0.\n\n\nsource\n\n\n#\n\n\nClimateTools.mapclimgrid\n \n \nMethod\n.\n\n\nmapclimgrid(C::ClimGrid; region::String=\nauto\n, poly, level, mask, caxis, start_date::Date, end_date::Date)\n\n\n\n\nMaps the time-mean average of ClimGrid C.\n\n\nOptional keyworkd includes precribed regions (see list below), spatial clipping by polygon (keyword \npoly\n) or mask (keyword \nmask\n, an array of NaNs and 1.0 of the same dimension as the data in ClimGrid C), start_date and end_date.\n\n\nArguments\n\n\nRegions\n\n\n\n\nEurope\n\n\nNorthAmerica\n\n\nCanada\n\n\nQuebec, QuebecNSP\n\n\nAmericas\n\n\nWorld, WorldAz, WorldEck4\n\n\nGreenwich\n\n\n\n\nsource\n\n\n#\n\n\nClimateTools.mapclimgrid\n \n \nMethod\n.\n\n\nmapclimgrid(; region::String=\nauto\n, poly, level, mask, caxis, start_date::Date, end_date::Date)\n\n\n\n\nEmpty map generator, when called without a ClimGrid as the positional argument.\n\n\nsource\n\n\n#\n\n\nClimateTools.meshgrid\n \n \nMethod\n.\n\n\nX, Y = meshgrid{T}(vx::AbstractVector{T}, vy::AbstractVector{T})\n\n\n\n\nThis function creates a 2-D mesh-grid in a format consistent with Matlab's function meshgrid(). XV and YV are vectors.\n\n\nsource\n\n\n#\n\n\nClimateTools.nc2julia\n \n \nMethod\n.\n\n\nnc2julia(file::String, variable::String; poly = Array{Float64}([]), start_date::Date, end_date::Date, data_units::String = \n)\n\n\n\n\nReturns a ClimGrid type with the data in \nfile\n of variable \nvar\n inside the polygon \npoly\n. Metadata is built-in the ClimGrid type, from the netCDF attributes.\n\n\nInside the ClimgGrid type, the data is stored into an AxisArray data type, with time, longitude/x and latitude/y dimensions.\n\n\nThe polygon provided should be in the -180, +180 longitude format. If the polygon crosses the International Date Line, the polygon should be splitted in multiple parts (i.e. multi-polygons).\n\n\nOptions for data_units are for precipitation : \"mm\", which converts the usual \"kg m-2 s-1\" unit found in netCDF files. For temperature : \"Celsius\", which converts the usual \"Kelvin\" unit.\n\n\nNote:\n nc2julia is based on CF conventions (http://cfconventions.org/). If you are unable to read the netCDF file with nc2julia, the user will need to read it with low-level functions available in the NetCDF.jl package (https://github.com/JuliaGeo/NetCDF.jl).\n\n\nsource\n\n\n#\n\n\nClimateTools.ndgrid\n \n \nMethod\n.\n\n\nX, Y = ndgrid(XV, YV)\n\n\n\n\nThis function creates a 2-D mesh-grid in a format consistent with Matlab's function ndgrid(). XV and YV are vectors.\n\n\nsource\n\n\n#\n\n\nClimateTools.pr_timefactor\n \n \nMethod\n.\n\n\nfunction pr_timefactor(rez::String)\n\n\n\n\nReturn the time factor that should be applied to precipitation to get accumulation for resolution \"rez\"\n\n\nsource\n\n\n#\n\n\nClimateTools.prcp1\n \n \nMethod\n.\n\n\nprcp1(data::AbstractArray, timevector::StepRange{Date,Base.Dates.Day})\n\n\n\n\nAnnual number with preciptation \n= 1 mm. This function returns a boolean vector. \ntrue\n if the data is higher or equal to 1 and \nfalse\n otherwise.\n\n\nsource\n\n\n#\n\n\nClimateTools.prcp1\n \n \nMethod\n.\n\n\nprcp1(C::ClimGrid)\n\n\n\n\nAnnual number with preciptation \n= 1 mm. This function returns a ClimGrid.\n\n\nsource\n\n\n#\n\n\nClimateTools.qqmap\n \n \nMethod\n.\n\n\nqqmap(obs::Array{N, 1} where N, ref::Array{N, 1} where N, fut::Array{N, 1} where N; method=\nAdditive\n, detrend=true, window=15, rankn=50, thresnan=0.1, keep_original=false, interp::Function = Linear(), extrap::Function = Flat())\n\n\n\n\nQuantile-Quantile mapping bias correction for single vector. This is a low level function used by qqmap(A::ClimGrid ..), but can work independently.\n\n\nsource\n\n\n#\n\n\nClimateTools.qqmap\n \n \nMethod\n.\n\n\nqqmap(obs::ClimGrid, ref::ClimGrid, fut::ClimGrid; method=\nAdditive\n, detrend=true, window::Int=15, rankn::Int=50, thresnan::Float64=0.1, keep_original::Bool=false, interp::Function = Linear(), extrap::Function = Flat())\n\n\n\n\nQuantile-Quantile mapping bias correction. For each julian day of the year (+/- \nwindow\n size), a transfer function is estimated through an empirical quantile-quantile mapping.\n\n\nThe quantile-quantile transfer function between \nref\n and \nobs\n is etimated on a julian day (and grid-point) basis with a moving window around the julian day. Hence, for a given julian day, the transfer function is then applied to the \nfut\n dataset for a given julian day.\n\n\nOptions\n\n\nmethod::String = \"Additive\" (default) or \"Multiplicative\"\n. Additive is used for most climate variables. Multiplicative is usually bounded variables such as precipitation and humidity.\n\n\ndetrend::Bool = true (default)\n. A 4th order polynomial is adjusted to the time series and the residuals are corrected with the quantile-quantile mapping.\n\n\nwindow::Int = 15 (default)\n. The size of the window used to extract the statistical characteristics around a given julian day.\n\n\nrankn::Int = 50 (default)\n. The number of bins used for the quantile estimations. The quantiles uses by default 50 bins between 0.01 and 0.99. The bahavior between the bins is controlled by the interp keyword argument. The behaviour of the quantile-quantile estimation outside the 0.01 and 0.99 range is controlled by the extrap keyword argument.\n\n\nthresnan::Float64 = 0.1 (default)\n. The fraction is missing values authorized for the estimation of the quantile-quantile mapping for a given julian days. If there is more than \ntreshnan\n missing values, the output for this given julian days returns NaNs.\n\n\nkeep_original::Bool = false (default)\n. If \nkeep_original\n is set to true, the values are set to the original values in presence of too many NaNs.\n\n\ninterp = Interpolations.Linear() (default)\n. When the data to be corrected lies between 2 quantile bins, the value of the transfer function is linearly interpolated between the 2 closest quantile estimation. The argument is from Interpolations.jl package.\n\n\nextrap = Interpolations.Flat() (default)\n. The bahavior of the quantile-quantile transfer function outside the 0.01-0.99 range. Setting it to Flat() ensures that there is no \"inflation problem\" with the bias correction. The argument is from Interpolation.jl package.\n\n\nsource\n\n\n#\n\n\nClimateTools.shapefile_coords\n \n \nMethod\n.\n\n\nshapefile_coords(poly::Shapefile.Polygon)\n\n\n\n\nThis function return the polygons contained in shp.shapes\ni\n. It returns the x and y coordinates vectors.\n\n\nSee also \nshapefile_coords_poly\n, which returns a polygon that ca be used for data extraction of the \nnc2julia\n.\n\n\nsource\n\n\n#\n\n\nClimateTools.shapefile_coords_poly\n \n \nMethod\n.\n\n\nshapefile_coords_poly(poly::Shapefile.Polygon)\n\n\n\n\nReturn the polygons contained in shp.shapes\ni\n. It returns an array containing the polygons.\n\n\nSee also \nshapefile_coords\n, which returns vectors as opposed to array. Returned polygon is consistent with the data extraction of the \nnc2julia\n function.\n\n\nsource\n\n\n#\n\n\nClimateTools.spatialsubset\n \n \nMethod\n.\n\n\nspatialsubset(C::ClimGrid, poly::Array{N, 2})\n\n\n\n\nReturns the spatial subset of ClimGrid C. The spatial subset is defined by the polygon poly, defined on a -180, +180 longitude reference.\n\n\nsource\n\n\n#\n\n\nClimateTools.sumleapyear\n \n \nMethod\n.\n\n\nNumber of leap years in date vector\n\n\nsumleapyear(dates::StepRange{Date,Base.Dates.Day})\n\nsumleapyear(initDate::Date, timeRaw)\n\n\n\n\nsource\n\n\n#\n\n\nClimateTools.summerdays\n \n \nMethod\n.\n\n\nsummerdays(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})\n\n\n\n\nSD, Number of summer days: Annual count of days when TX (daily maximum temperature) \n 25 degree Celsius.\n\n\nLet TX[i,j] be daily maximum temperature on day i in year j. Count the number of days where:\n\n\nTX[i,j] \n 25 Celsius.\n\n\nsource\n\n\n#\n\n\nClimateTools.summerdays\n \n \nMethod\n.\n\n\nsummerdays(C::ClimGrid)\n\n\n\n\nSD, Number of summer days: Annual count of days when TX (daily maximum temperature) \n 25 degree Celsius.\n\n\nLet TX[i,j] be daily maximum temperature on day i in year j. Count the number of days where:\n\n\nTX[i,j] \n 25 Celsius.\n\n\nsource\n\n\n#\n\n\nClimateTools.temporalsubset\n \n \nMethod\n.\n\n\nfunction temporalsubset(C::ClimGrid, startdate::Date, enddate::Date)\n\n\n\n\nReturns the temporal subset of ClimGrid C. The temporal subset is defined by a start and end date.\n\n\nsource\n\n\n#\n\n\nClimateTools.timeindex\n \n \nMethod\n.\n\n\ntimeindex(timeVec, start_date, end_date, freq)\n\n\n\n\nReturn the index of time vector specified by start_date and end_date. Provide timestep \"freq\" to account for monthly timestep.\n\n\nsource\n\n\n#\n\n\nClimateTools.timeresolution\n \n \nMethod\n.\n\n\ntimeresolution(timevec::Array{N,1} where N)\n\n\n\n\nReturn the time resolution of the vector timevec.\n\n\nsource\n\n\n#\n\n\nClimateTools.tropicalnights\n \n \nMethod\n.\n\n\ntropicalnights(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})\n\n\n\n\nTropicalNights, Number of tropical nights: Annual count of days when TN (daily maximum temperature) \n 20 degree Celsius.\n\n\nLet TN[i,j] be daily minimum temperature on day i in year j. Count the number of days where:\n\n\nTN[i,j] \n 20 Celsius.\n\n\nsource\n\n\n#\n\n\nClimateTools.tropicalnights\n \n \nMethod\n.\n\n\ntropicalnights(C::ClimGrid)\n\n\n\n\nTropicalNights, Number of tropical nights: Annual count of days when TN (daily maximum temperature) \n 20 degree Celsius.\n\n\nLet TN[i,j] be daily minimum temperature on day i in year j. Count the number of days where:\n\n\nTN[i,j] \n 20 Celsius.\n\n\nsource\n\n\n#\n\n\nClimateTools.windnr\n \n \nMethod\n.\n\n\nwindnr(p, poly::Matrix)\n\n\n\n\nDetermines the winding number of a point and a polygon, i.e. how many times a polygon winds around the point.\n\n\nIt follows Dan Sunday: http://geomalgorithms.com/a03-_inclusion.html.\n\n\nsource\n\n\n#\n\n\nClimateTools.ClimGrid\n \n \nType\n.\n\n\nClimGrid{A \n: AxisArray}\n\n\n\n\nIn-memory representation of Climate Forecast netCDF files.\n\n\nsource\n\n\n#\n\n\nClimateTools.ClimGrid\n \n \nMethod\n.\n\n\nClimGrid(data; longrid=[], latgrid=[], msk=[], grid_mapping=Dict(), dimension_dict=Dict(), model=\nNA\n, frequency=\nNA\n, experiment=\nNA\n, run=\nNA\n, project=\nNA\n, institute=\nNA\n, filename=\nNA\n, dataunits=\nNA\n, latunits=\nNA\n, lonunits=\nNA\n, variable=\nNA\n, typeofvar=\nNA\n, typeofcal=\nNA\n, varattribs=Dict(), globalattribs=Dict())\n\n\n\n\nConstructor of the ClimGrid function. Data is an AxisArray. Everything else is optional, but usually needed for further processing (mapping, interpolation, etc...).\n\n\nsource\n\n\n#\n\n\nBase.merge\n \n \nMethod\n.\n\n\nmerge(A::ClimGrid, B::ClimGrid)\n\n\n\n\nCombines two ClimGrid. Based on the AxisArrays method.\n\n\nsource\n\n\n#\n\n\nBase.vcat\n \n \nMethod\n.\n\n\nvcat(A::ClimGrid, B::ClimGrid)\n\n\n\n\nCombines two ClimGrid. Based on the AxisArrays method. Better way to do it would be to use the merge method.\n\n\nsource", 
            "title": "Index"
        }, 
        {
            "location": "/functions/#index", 
            "text": "#  Base.maximum     Method .  maximum(A::ClimGrid)  Compute the maximum value of  ClimGrid  A  source  #  Base.minimum     Method .  minimum(A::ClimGrid)  Compute the minimum value of  ClimGrid  A  source  #  Base.std     Method .  std(A::ClimGrid)  Compute the standard deviation of  ClimGrid  A  source  #  Base.var     Method .  var(A::ClimGrid)  Compute the variance of  ClimGrid  A  source  #  ClimateTools.annualmax     Method .  annualmax(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})  Annual maximum of array data.  Let data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.  source  #  ClimateTools.annualmax     Method .  annualmax(C::ClimGrid)  Annual maximum of array data.  Let data[i,j] be daily time serie on day i in year j. Extract the highest value for year j.  source  #  ClimateTools.annualmean     Method .  annualmean(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})  Annual mean of array data.  Let data[i,j] be daily time serie on day i in year j. Calculate the mean value for year j.  source  #  ClimateTools.annualmean     Method .  annualmean(C::ClimGrid)  Annual mean of array data.  Let data[i,j] be daily time serie on day i in year j. Calculate the mean value for year j.  source  #  ClimateTools.annualmin     Method .  annualmin(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})  Annual minimum of array data.  Let data[i,j] be daily time serie on day i in year j. Extract the lowest value for year j.  source  #  ClimateTools.annualmin     Method .  annualmin(C::ClimGrid)  Annual minimum of array data.  Let data[i,j] be daily time serie on day i in year j. Extract the lowest value for year j.  source  #  ClimateTools.annualsum     Method .  annualsum(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})  Value of annual sum of array data.  Let data[i,j] be daily time serie on day i in year j. Sums daily values for year j.  source  #  ClimateTools.annualsum     Method .  annualsum(C::ClimGrid)  Annual sum of array data.  Let data[i,j] be daily time serie on day i in year j. Sums daily values for year j.  source  #  ClimateTools.applymask     Method .  applymask(A::AbstractArray{N, n}, mask::AbstractArray{N, n})  This function applies a mask on the array A. Return an AbstractArray{N, n}.  source  #  ClimateTools.buildtimevec     Method .  buildtimevec(str::String)Y  Construct the time vector from the netCDF file str  source  #  ClimateTools.customthresover     Method .  customthresover(data::AbstractArray, time::StepRange{Date,Base.Dates.Day}, thres)  customthresover, annual number of days over a specified threshold.  Let TS[i,j] be a daily time serie value on day i in year j. Count the number of days where:  TS[i,j]   thres.  source  #  ClimateTools.customthresover     Method .  customthresover(C::ClimGrid)  customthresover, annual number of days over a specified threshold.  Let TS[i,j] be a daily time serie value on day i in year j. Count the number of days where:  TS[i,j]   thres.  source  #  ClimateTools.customthresunder     Method .  customthresunder(data::AbstractArray, time::StepRange{Date,Base.Dates.Day}, thres)  customthresover, annual number of days under a specified threshold.  Let TS[i,j] be a daily time serie value on day i in year j. Count the number of days where:  TS[i,j]   thres.  source  #  ClimateTools.customthresunder     Method .  customthresunder(C::ClimGrid)  customthresover, annual number of days under a specified threshold.  Let TS[i,j] be a daily time serie value on day i in year j. Count the number of days where:  TS[i,j]   thres.  source  #  ClimateTools.daysabove10     Method .  daysabove10(data::AbstractArray, timevector::StepRange{Date,Base.Dates.Day})  Annual number with temperature  = 10 Celsius. This function returns a boolean vector.  true  if the data is higher or equal to 1 and  false  otherwise.  source  #  ClimateTools.daysabove10     Method .  daysabove10(C::ClimGrid)  Annual number of days with temperature  = 10 Celsius. This function returns a ClimGrid.  source  #  ClimateTools.frostdays     Method .  frostdays(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})  FD, Number of frost days: Annual count of days when TN (daily minimum temperature)   0 Celsius.  Let TN[i,j] be daily minimum temperature on day i in year j. Count the number of days where:  TN[i,j]   0 Celsius.  source  #  ClimateTools.frostdays     Method .  frostdays(C::ClimGrid)  FD, Number of frost days: Annual count of days when TN (daily minimum temperature)   0 Celsius.  Let TN[i,j] be daily minimum temperature on day i in year j. Count the number of days where:  TN[i,j]   0 Celsius.  source  #  ClimateTools.icingdays     Method .  icingdays(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})  ID, Number of summer days: Annual count of days when TX (daily maximum temperature)   0 degree Celsius.  Let TX[i,j] be daily maximum temperature on day i in year j. Count the number of days where:  TX[i,j]   0 Celsius.  source  #  ClimateTools.icingdays     Method .  icingdays(C::ClimGrid)  ID, Number of summer days: Annual count of days when TX (daily maximum temperature)   0 degree Celsius.  Let TX[i,j] be daily maximum temperature on day i in year j. Count the number of days where:  TX[i,j]   0 Celsius.  source  #  ClimateTools.inpoly     Method .  inpoly(p, poly::Matrix)  Determines if a point is inside a polygon.   p \u2013 point (x,y) or [x,y]  poly \u2013 polygon vertices  x1 x2 ... xn x1                           y1 y2 ... yn y1   Returns true if point has an odd winding number.  This should label points as exterior which are inside outcrops.  See test for a test.  Author: Github \"Mauro3\" / \"Mauro\"  source  #  ClimateTools.inpolygrid     Method .  inpolygrid(lon, lat, poly::AbstractArray{N,2} where N)  Used to test a grid of points. Returns a mask of ones and NaNs of the same size as lon and lat.  source  #  ClimateTools.interp_climgrid     Method .  C = interp_climgrid(A::ClimGrid, londest::AbstractArray{N, 1} where N, latdest::AbstractArray{N, 1} where N)A  This function interpolate ClimGrid A onto lat-lon grid defined by londest and latdest vector.  source  #  ClimateTools.interp_climgrid     Method .  C = interp_climgrid(A::ClimGrid, B::ClimGrid; method= linear , min=[], max=[])  This function interpolate  ClimGrid  A onto the lon-lat grid of  ClimGrid  B, where A and B are  ClimGrid . Available methods for interpolation are \"linear\" (default), \"nearest\" and \"cubic\".  Min and max optional keyword are used to constraint the results of the interpolation. For example, interpolating bounded fields can lead to unrealilstic values, such as negative precipitation. In that case, one would use min=0.0 to convert negative precipitation to 0.0.  source  #  ClimateTools.mapclimgrid     Method .  mapclimgrid(C::ClimGrid; region::String= auto , poly, level, mask, caxis, start_date::Date, end_date::Date)  Maps the time-mean average of ClimGrid C.  Optional keyworkd includes precribed regions (see list below), spatial clipping by polygon (keyword  poly ) or mask (keyword  mask , an array of NaNs and 1.0 of the same dimension as the data in ClimGrid C), start_date and end_date.  Arguments  Regions   Europe  NorthAmerica  Canada  Quebec, QuebecNSP  Americas  World, WorldAz, WorldEck4  Greenwich   source  #  ClimateTools.mapclimgrid     Method .  mapclimgrid(; region::String= auto , poly, level, mask, caxis, start_date::Date, end_date::Date)  Empty map generator, when called without a ClimGrid as the positional argument.  source  #  ClimateTools.meshgrid     Method .  X, Y = meshgrid{T}(vx::AbstractVector{T}, vy::AbstractVector{T})  This function creates a 2-D mesh-grid in a format consistent with Matlab's function meshgrid(). XV and YV are vectors.  source  #  ClimateTools.nc2julia     Method .  nc2julia(file::String, variable::String; poly = Array{Float64}([]), start_date::Date, end_date::Date, data_units::String =  )  Returns a ClimGrid type with the data in  file  of variable  var  inside the polygon  poly . Metadata is built-in the ClimGrid type, from the netCDF attributes.  Inside the ClimgGrid type, the data is stored into an AxisArray data type, with time, longitude/x and latitude/y dimensions.  The polygon provided should be in the -180, +180 longitude format. If the polygon crosses the International Date Line, the polygon should be splitted in multiple parts (i.e. multi-polygons).  Options for data_units are for precipitation : \"mm\", which converts the usual \"kg m-2 s-1\" unit found in netCDF files. For temperature : \"Celsius\", which converts the usual \"Kelvin\" unit.  Note:  nc2julia is based on CF conventions (http://cfconventions.org/). If you are unable to read the netCDF file with nc2julia, the user will need to read it with low-level functions available in the NetCDF.jl package (https://github.com/JuliaGeo/NetCDF.jl).  source  #  ClimateTools.ndgrid     Method .  X, Y = ndgrid(XV, YV)  This function creates a 2-D mesh-grid in a format consistent with Matlab's function ndgrid(). XV and YV are vectors.  source  #  ClimateTools.pr_timefactor     Method .  function pr_timefactor(rez::String)  Return the time factor that should be applied to precipitation to get accumulation for resolution \"rez\"  source  #  ClimateTools.prcp1     Method .  prcp1(data::AbstractArray, timevector::StepRange{Date,Base.Dates.Day})  Annual number with preciptation  = 1 mm. This function returns a boolean vector.  true  if the data is higher or equal to 1 and  false  otherwise.  source  #  ClimateTools.prcp1     Method .  prcp1(C::ClimGrid)  Annual number with preciptation  = 1 mm. This function returns a ClimGrid.  source  #  ClimateTools.qqmap     Method .  qqmap(obs::Array{N, 1} where N, ref::Array{N, 1} where N, fut::Array{N, 1} where N; method= Additive , detrend=true, window=15, rankn=50, thresnan=0.1, keep_original=false, interp::Function = Linear(), extrap::Function = Flat())  Quantile-Quantile mapping bias correction for single vector. This is a low level function used by qqmap(A::ClimGrid ..), but can work independently.  source  #  ClimateTools.qqmap     Method .  qqmap(obs::ClimGrid, ref::ClimGrid, fut::ClimGrid; method= Additive , detrend=true, window::Int=15, rankn::Int=50, thresnan::Float64=0.1, keep_original::Bool=false, interp::Function = Linear(), extrap::Function = Flat())  Quantile-Quantile mapping bias correction. For each julian day of the year (+/-  window  size), a transfer function is estimated through an empirical quantile-quantile mapping.  The quantile-quantile transfer function between  ref  and  obs  is etimated on a julian day (and grid-point) basis with a moving window around the julian day. Hence, for a given julian day, the transfer function is then applied to the  fut  dataset for a given julian day.  Options  method::String = \"Additive\" (default) or \"Multiplicative\" . Additive is used for most climate variables. Multiplicative is usually bounded variables such as precipitation and humidity.  detrend::Bool = true (default) . A 4th order polynomial is adjusted to the time series and the residuals are corrected with the quantile-quantile mapping.  window::Int = 15 (default) . The size of the window used to extract the statistical characteristics around a given julian day.  rankn::Int = 50 (default) . The number of bins used for the quantile estimations. The quantiles uses by default 50 bins between 0.01 and 0.99. The bahavior between the bins is controlled by the interp keyword argument. The behaviour of the quantile-quantile estimation outside the 0.01 and 0.99 range is controlled by the extrap keyword argument.  thresnan::Float64 = 0.1 (default) . The fraction is missing values authorized for the estimation of the quantile-quantile mapping for a given julian days. If there is more than  treshnan  missing values, the output for this given julian days returns NaNs.  keep_original::Bool = false (default) . If  keep_original  is set to true, the values are set to the original values in presence of too many NaNs.  interp = Interpolations.Linear() (default) . When the data to be corrected lies between 2 quantile bins, the value of the transfer function is linearly interpolated between the 2 closest quantile estimation. The argument is from Interpolations.jl package.  extrap = Interpolations.Flat() (default) . The bahavior of the quantile-quantile transfer function outside the 0.01-0.99 range. Setting it to Flat() ensures that there is no \"inflation problem\" with the bias correction. The argument is from Interpolation.jl package.  source  #  ClimateTools.shapefile_coords     Method .  shapefile_coords(poly::Shapefile.Polygon)  This function return the polygons contained in shp.shapes i . It returns the x and y coordinates vectors.  See also  shapefile_coords_poly , which returns a polygon that ca be used for data extraction of the  nc2julia .  source  #  ClimateTools.shapefile_coords_poly     Method .  shapefile_coords_poly(poly::Shapefile.Polygon)  Return the polygons contained in shp.shapes i . It returns an array containing the polygons.  See also  shapefile_coords , which returns vectors as opposed to array. Returned polygon is consistent with the data extraction of the  nc2julia  function.  source  #  ClimateTools.spatialsubset     Method .  spatialsubset(C::ClimGrid, poly::Array{N, 2})  Returns the spatial subset of ClimGrid C. The spatial subset is defined by the polygon poly, defined on a -180, +180 longitude reference.  source  #  ClimateTools.sumleapyear     Method .  Number of leap years in date vector  sumleapyear(dates::StepRange{Date,Base.Dates.Day})\n\nsumleapyear(initDate::Date, timeRaw)  source  #  ClimateTools.summerdays     Method .  summerdays(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})  SD, Number of summer days: Annual count of days when TX (daily maximum temperature)   25 degree Celsius.  Let TX[i,j] be daily maximum temperature on day i in year j. Count the number of days where:  TX[i,j]   25 Celsius.  source  #  ClimateTools.summerdays     Method .  summerdays(C::ClimGrid)  SD, Number of summer days: Annual count of days when TX (daily maximum temperature)   25 degree Celsius.  Let TX[i,j] be daily maximum temperature on day i in year j. Count the number of days where:  TX[i,j]   25 Celsius.  source  #  ClimateTools.temporalsubset     Method .  function temporalsubset(C::ClimGrid, startdate::Date, enddate::Date)  Returns the temporal subset of ClimGrid C. The temporal subset is defined by a start and end date.  source  #  ClimateTools.timeindex     Method .  timeindex(timeVec, start_date, end_date, freq)  Return the index of time vector specified by start_date and end_date. Provide timestep \"freq\" to account for monthly timestep.  source  #  ClimateTools.timeresolution     Method .  timeresolution(timevec::Array{N,1} where N)  Return the time resolution of the vector timevec.  source  #  ClimateTools.tropicalnights     Method .  tropicalnights(data::AbstractArray, time::StepRange{Date,Base.Dates.Day})  TropicalNights, Number of tropical nights: Annual count of days when TN (daily maximum temperature)   20 degree Celsius.  Let TN[i,j] be daily minimum temperature on day i in year j. Count the number of days where:  TN[i,j]   20 Celsius.  source  #  ClimateTools.tropicalnights     Method .  tropicalnights(C::ClimGrid)  TropicalNights, Number of tropical nights: Annual count of days when TN (daily maximum temperature)   20 degree Celsius.  Let TN[i,j] be daily minimum temperature on day i in year j. Count the number of days where:  TN[i,j]   20 Celsius.  source  #  ClimateTools.windnr     Method .  windnr(p, poly::Matrix)  Determines the winding number of a point and a polygon, i.e. how many times a polygon winds around the point.  It follows Dan Sunday: http://geomalgorithms.com/a03-_inclusion.html.  source  #  ClimateTools.ClimGrid     Type .  ClimGrid{A  : AxisArray}  In-memory representation of Climate Forecast netCDF files.  source  #  ClimateTools.ClimGrid     Method .  ClimGrid(data; longrid=[], latgrid=[], msk=[], grid_mapping=Dict(), dimension_dict=Dict(), model= NA , frequency= NA , experiment= NA , run= NA , project= NA , institute= NA , filename= NA , dataunits= NA , latunits= NA , lonunits= NA , variable= NA , typeofvar= NA , typeofcal= NA , varattribs=Dict(), globalattribs=Dict())  Constructor of the ClimGrid function. Data is an AxisArray. Everything else is optional, but usually needed for further processing (mapping, interpolation, etc...).  source  #  Base.merge     Method .  merge(A::ClimGrid, B::ClimGrid)  Combines two ClimGrid. Based on the AxisArrays method.  source  #  Base.vcat     Method .  vcat(A::ClimGrid, B::ClimGrid)  Combines two ClimGrid. Based on the AxisArrays method. Better way to do it would be to use the merge method.  source", 
            "title": "Index"
        }
    ]
}